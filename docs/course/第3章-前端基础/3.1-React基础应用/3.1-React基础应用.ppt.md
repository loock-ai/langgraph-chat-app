---
marp: true
theme: gaia
paginate: true
header: '3.1-React基础应用'
style: |
  section {
    font-size: 30px;
  }
---

<!-- _class: lead -->
# 3.1 React基础应用 ⚛️

## 掌握现代化组件开发

**LangGraph智能聊天应用开发教程**

---

## 🎯 学习目标概述

### 本节课的核心价值
- **⚛️ 掌握React核心概念**：组件化、状态管理、生命周期
- **🎣 精通Hooks应用**：现代React开发的核心技术
- **🏗️ 构建聊天组件**：实际应用中的组件设计和实现
- **📱 响应式布局**：适配不同设备的界面设计

### 具体学习目标
- 理解React组件的工作原理
- 掌握useState和useEffect的使用
- 创建聊天应用的核心组件
- 实现组件间的数据传递和状态管理

---

## ⚛️ React核心概念

### 什么是React？
React是一个用于构建用户界面的JavaScript库：

- **🧩 组件化**：将UI分解为独立、可复用的组件
- **🔄 声明式**：描述界面应该如何显示，而不是如何操作DOM
- **⚡ 高效更新**：虚拟DOM确保最小化的DOM操作
- **🌐 生态丰富**：庞大的社区和工具生态系统

### React的核心原理
```
数据变化 → 状态更新 → 重新渲染 → UI更新
     ↑                              ↓
   用户交互 ← 事件处理 ← 虚拟DOM Diff ← 新虚拟DOM
```

---

## 🧩 组件基础概念

### 函数组件vs类组件
```tsx
// 函数组件（推荐）
function ChatMessage({ message, isUser }) {
  return (
    <div className={`message ${isUser ? 'user' : 'assistant'}`}>
      {message}
    </div>
  );
}

// 箭头函数组件
const ChatMessage = ({ message, isUser }) => (
  <div className={`message ${isUser ? 'user' : 'assistant'}`}>
    {message}
  </div>
);
```

### 组件的特点
- **🔒 封装性**：每个组件管理自己的状态和逻辑
- **🔄 可复用性**：同一组件可在多处使用
- **📦 组合性**：小组件组合成大组件
- **🎯 单一职责**：每个组件有明确的功能

---

## 🎣 React Hooks详解

### useState - 状态管理
```tsx
import { useState } from 'react';

function MessageInput() {
  // 状态声明
  const [message, setMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
    
    try {
      // 发送消息逻辑
      await sendMessage(message);
      setMessage(''); // 清空输入
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={message}
        onChange={(e) => setMessage(e.target.value)}
        disabled={isLoading}
        placeholder="输入消息..."
      />
      <button type="submit" disabled={!message.trim() || isLoading}>
        {isLoading ? '发送中...' : '发送'}
      </button>
    </form>
  );
}
```

---

## 🔄 useEffect副作用处理

### 基础用法
```tsx
import { useState, useEffect } from 'react';

function ChatContainer() {
  const [messages, setMessages] = useState([]);
  const [sessionId, setSessionId] = useState(null);

  // 组件挂载时执行
  useEffect(() => {
    // 创建新会话
    createNewSession().then(setSessionId);
  }, []); // 空依赖数组，只执行一次

  // 当sessionId变化时加载消息
  useEffect(() => {
    if (sessionId) {
      loadMessages(sessionId).then(setMessages);
    }
  }, [sessionId]); // 依赖sessionId

  // 清理副作用
  useEffect(() => {
    const interval = setInterval(() => {
      // 定期检查新消息
      checkNewMessages();
    }, 1000);

    return () => clearInterval(interval); // 清理函数
  }, []);

  return (
    <div className="chat-container">
      {messages.map(message => (
        <ChatMessage key={message.id} {...message} />
      ))}
    </div>
  );
}
```

---

## 🎨 聊天消息组件

### 消息组件设计
```tsx
// types/chat.ts
interface Message {
  id: string;
  content: string;
  role: 'user' | 'assistant' | 'system';
  timestamp: Date;
  isLoading?: boolean;
}

// components/ChatMessage.tsx
import { formatTime } from '@/utils/dateUtils';

interface ChatMessageProps {
  message: Message;
}

export function ChatMessage({ message }: ChatMessageProps) {
  const isUser = message.role === 'user';
  const isSystem = message.role === 'system';
  
  if (isSystem) {
    return (
      <div className="flex justify-center my-4">
        <span className="text-sm text-gray-500 bg-gray-100 px-3 py-1 rounded-full">
          {message.content}
        </span>
      </div>
    );
  }

  return (
    <div className={`flex ${isUser ? 'justify-end' : 'justify-start'} mb-4`}>
      <div
        className={`max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${
          isUser
            ? 'bg-blue-500 text-white'
            : 'bg-gray-200 text-gray-800'
        }`}
      >
        <p className="text-sm">{message.content}</p>
        <p className={`text-xs mt-1 ${
          isUser ? 'text-blue-100' : 'text-gray-500'
        }`}>
          {formatTime(message.timestamp)}
        </p>
        {message.isLoading && (
          <div className="mt-2">
            <div className="typing-indicator">
              <span></span>
              <span></span>
              <span></span>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
```

---

## 📝 消息输入组件

### 输入组件实现
```tsx
// components/MessageInput.tsx
import { useState, KeyboardEvent } from 'react';

interface MessageInputProps {
  onSendMessage: (message: string) => Promise<void>;
  disabled?: boolean;
}

export function MessageInput({ onSendMessage, disabled = false }: MessageInputProps) {
  const [message, setMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async () => {
    if (!message.trim() || isLoading) return;

    const messageToSend = message.trim();
    setMessage('');
    setIsLoading(true);

    try {
      await onSendMessage(messageToSend);
    } catch (error) {
      console.error('发送消息失败:', error);
      // 可以添加错误提示
    } finally {
      setIsLoading(false);
    }
  };

  const handleKeyPress = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit();
    }
  };

  return (
    <div className="flex items-end space-x-2 p-4 bg-white border-t">
      <textarea
        value={message}
        onChange={(e) => setMessage(e.target.value)}
        onKeyPress={handleKeyPress}
        placeholder="输入消息... (Shift+Enter换行)"
        className="flex-1 resize-none rounded-lg border border-gray-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
        rows={1}
        disabled={disabled || isLoading}
        style={{
          minHeight: '40px',
          maxHeight: '120px',
        }}
      />
      <button
        onClick={handleSubmit}
        disabled={!message.trim() || isLoading || disabled}
        className="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
      >
        {isLoading ? '发送中...' : '发送'}
      </button>
    </div>
  );
}
```

---

## 📱 会话侧边栏组件

### 侧边栏设计
```tsx
// components/SessionSidebar.tsx
import { useState, useEffect } from 'react';

interface Session {
  id: string;
  title: string;
  lastMessage?: string;
  updatedAt: Date;
}

interface SessionSidebarProps {
  currentSessionId?: string;
  onSessionSelect: (sessionId: string) => void;
  onNewSession: () => void;
}

export function SessionSidebar({ 
  currentSessionId, 
  onSessionSelect, 
  onNewSession 
}: SessionSidebarProps) {
  const [sessions, setSessions] = useState<Session[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    loadSessions();
  }, []);

  const loadSessions = async () => {
    try {
      setIsLoading(true);
      const sessionsData = await fetch('/api/sessions').then(res => res.json());
      setSessions(sessionsData);
    } catch (error) {
      console.error('加载会话失败:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleDeleteSession = async (sessionId: string, e: React.MouseEvent) => {
    e.stopPropagation(); // 防止触发选择事件
    
    if (confirm('确定要删除这个会话吗？')) {
      try {
        await fetch(`/api/sessions/${sessionId}`, { method: 'DELETE' });
        setSessions(prev => prev.filter(s => s.id !== sessionId));
      } catch (error) {
        console.error('删除会话失败:', error);
      }
    }
  };

  if (isLoading) {
    return (
      <div className="w-64 bg-gray-50 border-r border-gray-200 p-4">
        <div className="animate-pulse">
          <div className="h-4 bg-gray-200 rounded mb-4"></div>
          <div className="space-y-2">
            {[...Array(5)].map((_, i) => (
              <div key={i} className="h-10 bg-gray-200 rounded"></div>
            ))}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="w-64 bg-gray-50 border-r border-gray-200 flex flex-col">
      <div className="p-4 border-b border-gray-200">
        <button
          onClick={onNewSession}
          className="w-full bg-blue-500 text-white py-2 px-4 rounded-lg hover:bg-blue-600"
        >
          新建对话
        </button>
      </div>
      
      <div className="flex-1 overflow-y-auto">
        {sessions.map((session) => (
          <div
            key={session.id}
            onClick={() => onSessionSelect(session.id)}
            className={`p-3 cursor-pointer hover:bg-gray-100 border-b border-gray-100 ${
              currentSessionId === session.id ? 'bg-blue-50 border-l-4 border-l-blue-500' : ''
            }`}
          >
            <div className="flex justify-between items-start">
              <div className="flex-1 min-w-0">
                <h3 className="text-sm font-medium text-gray-900 truncate">
                  {session.title}
                </h3>
                {session.lastMessage && (
                  <p className="text-xs text-gray-500 truncate mt-1">
                    {session.lastMessage}
                  </p>
                )}
                <p className="text-xs text-gray-400 mt-1">
                  {formatRelativeTime(session.updatedAt)}
                </p>
              </div>
              <button
                onClick={(e) => handleDeleteSession(session.id, e)}
                className="text-gray-400 hover:text-red-500 ml-2"
                title="删除会话"
              >
                <TrashIcon className="w-4 h-4" />
              </button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

---

## 🔗 组件组合与状态管理

### 主聊天容器组件
```tsx
// components/ChatContainer.tsx
import { useState, useEffect, useRef } from 'react';
import { ChatMessage } from './ChatMessage';
import { MessageInput } from './MessageInput';
import { SessionSidebar } from './SessionSidebar';

export function ChatContainer() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [currentSessionId, setCurrentSessionId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  // 自动滚动到最新消息
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  // 发送消息
  const handleSendMessage = async (content: string) => {
    if (!currentSessionId) {
      const newSession = await createNewSession();
      setCurrentSessionId(newSession.id);
    }

    // 添加用户消息
    const userMessage: Message = {
      id: Date.now().toString(),
      content,
      role: 'user',
      timestamp: new Date(),
    };
    setMessages(prev => [...prev, userMessage]);

    setIsLoading(true);
    try {
      // 调用AI API
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: content,
          sessionId: currentSessionId,
        }),
      });

      const aiMessage: Message = await response.json();
      setMessages(prev => [...prev, aiMessage]);
    } catch (error) {
      console.error('发送消息失败:', error);
      // 添加错误消息
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: '抱歉，消息发送失败，请重试。',
        role: 'system',
        timestamp: new Date(),
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  // 选择会话
  const handleSessionSelect = async (sessionId: string) => {
    setCurrentSessionId(sessionId);
    setIsLoading(true);
    try {
      const sessionMessages = await fetch(`/api/sessions/${sessionId}/messages`)
        .then(res => res.json());
      setMessages(sessionMessages);
    } finally {
      setIsLoading(false);
    }
  };

  // 创建新会话
  const handleNewSession = () => {
    setCurrentSessionId(null);
    setMessages([]);
  };

  return (
    <div className="flex h-screen bg-gray-100">
      <SessionSidebar
        currentSessionId={currentSessionId}
        onSessionSelect={handleSessionSelect}
        onNewSession={handleNewSession}
      />
      
      <div className="flex-1 flex flex-col">
        {/* 消息区域 */}
        <div className="flex-1 overflow-y-auto p-4">
          {messages.length === 0 ? (
            <div className="flex items-center justify-center h-full text-gray-500">
              <div className="text-center">
                <h2 className="text-xl font-semibold mb-2">开始对话</h2>
                <p>发送消息开始与AI助手的对话</p>
              </div>
            </div>
          ) : (
            <>
              {messages.map((message) => (
                <ChatMessage key={message.id} message={message} />
              ))}
              <div ref={messagesEndRef} />
            </>
          )}
        </div>

        {/* 输入区域 */}
        <MessageInput
          onSendMessage={handleSendMessage}
          disabled={isLoading}
        />
      </div>
    </div>
  );
}
```

---

## 🛠️ 自定义Hooks

### useChat Hook
```tsx
// hooks/useChat.ts
import { useState, useCallback } from 'react';

export function useChat() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const sendMessage = useCallback(async (content: string, sessionId?: string) => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: content,
          sessionId,
        }),
      });

      if (!response.ok) {
        throw new Error('发送消息失败');
      }

      const result = await response.json();
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : '未知错误';
      setError(errorMessage);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, []);

  const addMessage = useCallback((message: Message) => {
    setMessages(prev => [...prev, message]);
  }, []);

  const clearMessages = useCallback(() => {
    setMessages([]);
  }, []);

  return {
    messages,
    isLoading,
    error,
    sendMessage,
    addMessage,
    clearMessages,
  };
}
```

### useLocalStorage Hook
```tsx
// hooks/useLocalStorage.ts
import { useState, useEffect } from 'react';

export function useLocalStorage<T>(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue] as const;
}
```

---

## 🎨 样式和动画

### TailwindCSS样式技巧
```tsx
// 渐变背景
<div className="bg-gradient-to-r from-blue-500 to-purple-600">

// 响应式设计
<div className="w-full md:w-1/2 lg:w-1/3">

// 状态样式
<button className={`
  px-4 py-2 rounded-lg transition-colors
  ${isActive 
    ? 'bg-blue-500 text-white' 
    : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
  }
`}>

// 动画效果
<div className="animate-pulse">
<div className="transform transition-transform hover:scale-105">
```

### CSS动画示例
```css
/* 打字指示器动画 */
.typing-indicator {
  display: flex;
  gap: 4px;
}

.typing-indicator span {
  width: 6px;
  height: 6px;
  background-color: currentColor;
  border-radius: 50%;
  animation: typing 1.4s infinite ease-in-out;
}

.typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
.typing-indicator span:nth-child(2) { animation-delay: -0.16s; }

@keyframes typing {
  0%, 80%, 100% { transform: scale(0); opacity: 0.5; }
  40% { transform: scale(1); opacity: 1; }
}

/* 消息滑入动画 */
.message-enter {
  opacity: 0;
  transform: translateY(20px);
}

.message-enter-active {
  opacity: 1;
  transform: translateY(0);
  transition: opacity 300ms, transform 300ms;
}
```

---

## 🧪 性能优化技巧

### React.memo优化
```tsx
import { memo } from 'react';

export const ChatMessage = memo(({ message }: ChatMessageProps) => {
  // 组件实现
}, (prevProps, nextProps) => {
  // 自定义比较函数
  return prevProps.message.id === nextProps.message.id &&
         prevProps.message.content === nextProps.message.content;
});
```

### useMemo和useCallback
```tsx
import { useMemo, useCallback } from 'react';

function ChatContainer() {
  const [messages, setMessages] = useState([]);
  const [filter, setFilter] = useState('');

  // 缓存计算结果
  const filteredMessages = useMemo(() => {
    return messages.filter(msg => 
      msg.content.toLowerCase().includes(filter.toLowerCase())
    );
  }, [messages, filter]);

  // 缓存回调函数
  const handleSendMessage = useCallback(async (content: string) => {
    // 发送消息逻辑
  }, []);

  return (
    <div>
      {filteredMessages.map(message => (
        <ChatMessage 
          key={message.id} 
          message={message}
          onReply={handleSendMessage}
        />
      ))}
    </div>
  );
}
```

---

## ✅ React基础应用总结

### 核心概念掌握
- ✅ **组件化思维**：将UI分解为可复用的组件
- ✅ **状态管理**：使用useState管理组件状态
- ✅ **副作用处理**：使用useEffect处理副作用
- ✅ **事件处理**：处理用户交互和表单提交

### 实战技能获得
- ✅ **聊天界面组件**：消息展示、输入框、侧边栏
- ✅ **自定义Hooks**：复用状态逻辑和副作用
- ✅ **性能优化**：memo、useMemo、useCallback
- ✅ **样式应用**：TailwindCSS的实际应用

### 下一步学习
现在你已经掌握了React的基础应用，接下来将学习Next.js的强大功能！

---

<!-- _class: lead -->
# 🎉 React基础应用完成！

## 准备探索Next.js的强大功能

**下一节：Next.js项目应用**
