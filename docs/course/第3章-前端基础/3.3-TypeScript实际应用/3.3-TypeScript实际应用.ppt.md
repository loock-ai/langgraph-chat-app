---
marp: true
theme: gaia
paginate: true
header: '3.3-TypeScript实际应用'
style: |
  section {
    font-size: 30px;
  }
---

<!-- _class: lead -->
# 3.3 TypeScript实际应用 📘

## 构建类型安全的AI聊天应用

**LangGraph智能聊天应用开发教程**

---

## 🎯 学习目标概述

### 本节课的核心价值
- **🔒 掌握类型安全开发**：预防运行时错误，提升代码质量
- **📖 提升代码可读性**：自文档化的类型注解和接口定义
- **🛠️ 优化开发体验**：IDE智能提示、自动重构、错误检查
- **🏗️ 构建可维护代码**：清晰的类型系统支撑大型应用

### 具体学习目标
- 为AI聊天应用定义完整的类型系统
- 掌握TypeScript高级类型特性
- 实现类型安全的API交互
- 学会泛型和工具类型的实际应用

---

## 📘 TypeScript核心概念

### 为什么选择TypeScript？
```
🔒 类型安全      ➜  编译时发现错误，减少运行时bug
📚 智能提示      ➜  IDE提供精确的代码补全和导航
🔄 重构支持      ➜  安全的代码重构和批量修改
📖 自文档化      ➜  类型即文档，提升代码可读性
👥 团队协作      ➜  统一的类型约定，减少沟通成本
```

### TypeScript vs JavaScript
```typescript
// JavaScript - 运行时才发现错误
function sendMessage(content, sessionId) {
  return fetch('/api/chat', {
    method: 'POST',
    body: JSON.stringify({ content, sessionId })
  });
}

// TypeScript - 编译时类型检查
function sendMessage(content: string, sessionId?: string): Promise<ChatResponse> {
  return fetch('/api/chat', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content, sessionId })
  }).then(res => res.json());
}
```

---

## 🏗️ 聊天应用类型系统设计

### 基础数据类型定义
```typescript
// types/chat.ts

// 消息角色枚举
export enum MessageRole {
  USER = 'user',
  ASSISTANT = 'assistant',
  SYSTEM = 'system'
}

// 消息接口
export interface Message {
  id: string;
  content: string;
  role: MessageRole;
  timestamp: Date;
  sessionId: string;
  metadata?: Record<string, unknown>;
  isLoading?: boolean;
  error?: string;
}

// 会话接口
export interface Session {
  id: string;
  title: string;
  createdAt: Date;
  updatedAt: Date;
  messageCount: number;
  lastMessage?: string;
  settings?: SessionSettings;
}

// 会话设置
export interface SessionSettings {
  temperature: number;
  maxTokens: number;
  model: string;
  systemPrompt?: string;
}
```

### API响应类型
```typescript
// types/api.ts

// 基础API响应
export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

// 聊天API响应
export interface ChatResponse extends ApiResponse<Message> {
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
}

// 会话列表响应
export interface SessionListResponse extends ApiResponse<Session[]> {
  pagination?: {
    total: number;
    page: number;
    limit: number;
    hasNext: boolean;
  };
}

// 流式响应事件
export interface StreamEvent {
  type: 'start' | 'token' | 'end' | 'error';
  content?: string;
  error?: string;
  metadata?: Record<string, unknown>;
}
```

---

## 🛡️ 类型守卫和验证

### 类型守卫函数
```typescript
// utils/typeGuards.ts

// 检查是否为有效消息
export function isValidMessage(obj: unknown): obj is Message {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    typeof (obj as Message).id === 'string' &&
    typeof (obj as Message).content === 'string' &&
    Object.values(MessageRole).includes((obj as Message).role) &&
    (obj as Message).timestamp instanceof Date
  );
}

// 检查API响应
export function isApiResponse<T>(obj: unknown): obj is ApiResponse<T> {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    typeof (obj as ApiResponse).success === 'boolean'
  );
}

// 检查流式事件
export function isStreamEvent(obj: unknown): obj is StreamEvent {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    ['start', 'token', 'end', 'error'].includes((obj as StreamEvent).type)
  );
}

// 使用示例
function processApiResponse(response: unknown) {
  if (isApiResponse<Message>(response)) {
    if (response.success && response.data) {
      // TypeScript知道response.data是Message类型
      console.log(`收到消息: ${response.data.content}`);
    } else {
      console.error(`API错误: ${response.error}`);
    }
  }
}
```

### 运行时验证库集成
```typescript
// utils/validation.ts
import { z } from 'zod';

// Zod模式定义
export const MessageSchema = z.object({
  id: z.string(),
  content: z.string().min(1),
  role: z.enum(['user', 'assistant', 'system']),
  timestamp: z.date(),
  sessionId: z.string(),
  metadata: z.record(z.unknown()).optional(),
  isLoading: z.boolean().optional(),
  error: z.string().optional(),
});

export const SessionSchema = z.object({
  id: z.string(),
  title: z.string().min(1),
  createdAt: z.date(),
  updatedAt: z.date(),
  messageCount: z.number().min(0),
  lastMessage: z.string().optional(),
});

// 类型推断
export type Message = z.infer<typeof MessageSchema>;
export type Session = z.infer<typeof SessionSchema>;

// 验证函数
export function validateMessage(data: unknown): Message {
  return MessageSchema.parse(data);
}

export function safeValidateMessage(data: unknown): Message | null {
  const result = MessageSchema.safeParse(data);
  return result.success ? result.data : null;
}
```

---

## 🔧 React组件类型定义

### 组件Props类型
```typescript
// components/ChatMessage.tsx
import { ReactNode } from 'react';

// 基础Props
interface ChatMessageProps {
  message: Message;
  onEdit?: (messageId: string, newContent: string) => void;
  onDelete?: (messageId: string) => void;
  onRegenerate?: (messageId: string) => void;
  className?: string;
  children?: ReactNode;
}

// 使用泛型的Props
interface ListProps<T> {
  items: T[];
  renderItem: (item: T, index: number) => ReactNode;
  keyExtractor: (item: T) => string;
  loading?: boolean;
  emptyMessage?: string;
}

// 组件实现
export function ChatMessage({ 
  message, 
  onEdit, 
  onDelete, 
  onRegenerate,
  className = '',
  children 
}: ChatMessageProps) {
  const isUser = message.role === MessageRole.USER;
  
  return (
    <div className={`message ${isUser ? 'user' : 'assistant'} ${className}`}>
      <div className="message-content">
        {message.content}
      </div>
      {children}
      <div className="message-actions">
        {onEdit && (
          <button onClick={() => onEdit(message.id, message.content)}>
            编辑
          </button>
        )}
        {onDelete && (
          <button onClick={() => onDelete(message.id)}>
            删除
          </button>
        )}
        {onRegenerate && message.role === MessageRole.ASSISTANT && (
          <button onClick={() => onRegenerate(message.id)}>
            重新生成
          </button>
        )}
      </div>
    </div>
  );
}
```

### Hooks类型定义
```typescript
// hooks/useChat.ts
import { useState, useCallback, useRef } from 'react';

// Hook返回类型
interface UseChatReturn {
  messages: Message[];
  isLoading: boolean;
  error: string | null;
  sendMessage: (content: string) => Promise<void>;
  editMessage: (messageId: string, newContent: string) => Promise<void>;
  deleteMessage: (messageId: string) => void;
  clearMessages: () => void;
  retryLastMessage: () => Promise<void>;
}

// Hook选项类型
interface UseChatOptions {
  sessionId?: string;
  onError?: (error: Error) => void;
  onMessageReceived?: (message: Message) => void;
  autoScroll?: boolean;
}

export function useChat(options: UseChatOptions = {}): UseChatReturn {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const abortControllerRef = useRef<AbortController | null>(null);

  const sendMessage = useCallback(async (content: string) => {
    if (!content.trim() || isLoading) return;

    // 添加用户消息
    const userMessage: Message = {
      id: `user-${Date.now()}`,
      content: content.trim(),
      role: MessageRole.USER,
      timestamp: new Date(),
      sessionId: options.sessionId || 'default',
    };

    setMessages(prev => [...prev, userMessage]);
    setIsLoading(true);
    setError(null);

    // 取消之前的请求
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    const abortController = new AbortController();
    abortControllerRef.current = abortController;

    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: content,
          sessionId: options.sessionId,
        }),
        signal: abortController.signal,
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const result: ChatResponse = await response.json();
      
      if (result.success && result.data) {
        setMessages(prev => [...prev, result.data!]);
        options.onMessageReceived?.(result.data);
      } else {
        throw new Error(result.error || '发送消息失败');
      }
    } catch (err) {
      if (err instanceof Error && err.name === 'AbortError') {
        return; // 请求被取消，不处理
      }
      
      const errorMessage = err instanceof Error ? err.message : '未知错误';
      setError(errorMessage);
      options.onError?.(err instanceof Error ? err : new Error(errorMessage));
    } finally {
      setIsLoading(false);
      abortControllerRef.current = null;
    }
  }, [isLoading, options]);

  const editMessage = useCallback(async (messageId: string, newContent: string) => {
    // 编辑消息逻辑
    setMessages(prev => 
      prev.map(msg => 
        msg.id === messageId 
          ? { ...msg, content: newContent, updatedAt: new Date() }
          : msg
      )
    );
  }, []);

  const deleteMessage = useCallback((messageId: string) => {
    setMessages(prev => prev.filter(msg => msg.id !== messageId));
  }, []);

  const clearMessages = useCallback(() => {
    setMessages([]);
    setError(null);
  }, []);

  const retryLastMessage = useCallback(async () => {
    const lastUserMessage = messages
      .filter(msg => msg.role === MessageRole.USER)
      .pop();
    
    if (lastUserMessage) {
      await sendMessage(lastUserMessage.content);
    }
  }, [messages, sendMessage]);

  return {
    messages,
    isLoading,
    error,
    sendMessage,
    editMessage,
    deleteMessage,
    clearMessages,
    retryLastMessage,
  };
}
```

---

## 🌐 API客户端类型安全

### API客户端类
```typescript
// utils/apiClient.ts

// API配置
interface ApiConfig {
  baseUrl: string;
  timeout: number;
  headers?: Record<string, string>;
}

// API错误类
export class ApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public response?: unknown
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

// API客户端类
export class ChatApiClient {
  private config: ApiConfig;

  constructor(config: Partial<ApiConfig> = {}) {
    this.config = {
      baseUrl: '/api',
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
      },
      ...config,
    };
  }

  // 通用请求方法
  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.config.baseUrl}${endpoint}`;
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);

    try {
      const response = await fetch(url, {
        ...options,
        headers: {
          ...this.config.headers,
          ...options.headers,
        },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorData = await response.json().catch(() => null);
        throw new ApiError(
          errorData?.error || `HTTP ${response.status}`,
          response.status,
          errorData
        );
      }

      return response.json();
    } catch (error) {
      clearTimeout(timeoutId);
      
      if (error instanceof ApiError) {
        throw error;
      }
      
      throw new ApiError(
        error instanceof Error ? error.message : '网络请求失败',
        0
      );
    }
  }

  // 发送消息
  async sendMessage(content: string, sessionId?: string): Promise<ChatResponse> {
    return this.request<ChatResponse>('/chat', {
      method: 'POST',
      body: JSON.stringify({ message: content, sessionId }),
    });
  }

  // 获取会话列表
  async getSessions(): Promise<SessionListResponse> {
    return this.request<SessionListResponse>('/sessions');
  }

  // 创建新会话
  async createSession(title?: string): Promise<ApiResponse<Session>> {
    return this.request<ApiResponse<Session>>('/sessions', {
      method: 'POST',
      body: JSON.stringify({ title }),
    });
  }

  // 获取会话详情
  async getSession(sessionId: string): Promise<ApiResponse<Session>> {
    return this.request<ApiResponse<Session>>(`/sessions/${sessionId}`);
  }

  // 删除会话
  async deleteSession(sessionId: string): Promise<ApiResponse> {
    return this.request<ApiResponse>(`/sessions/${sessionId}`, {
      method: 'DELETE',
    });
  }

  // 流式聊天
  async *streamChat(content: string, sessionId?: string): AsyncGenerator<StreamEvent> {
    const response = await fetch(`${this.config.baseUrl}/chat/stream`, {
      method: 'POST',
      headers: this.config.headers,
      body: JSON.stringify({ message: content, sessionId }),
    });

    if (!response.ok) {
      throw new ApiError(`HTTP ${response.status}`, response.status);
    }

    const reader = response.body?.getReader();
    if (!reader) {
      throw new ApiError('无法读取响应流', 0);
    }

    const decoder = new TextDecoder();
    let buffer = '';

    try {
      while (true) {
        const { done, value } = await reader.read();
        
        if (done) break;
        
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.slice(6));
              if (isStreamEvent(data)) {
                yield data;
              }
            } catch (error) {
              console.warn('解析流数据失败:', error);
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }
}

// 创建API客户端实例
export const apiClient = new ChatApiClient();
```

---

## 🔧 高级类型特性应用

### 工具类型使用
```typescript
// types/utils.ts

// 部分更新类型
export type PartialUpdate<T> = Partial<Pick<T, keyof T>>;

// 必需字段类型
export type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>;

// 排除字段类型
export type OmitFields<T, K extends keyof T> = Omit<T, K>;

// 提取字段类型
export type PickFields<T, K extends keyof T> = Pick<T, K>;

// 实际应用示例
export type CreateSessionRequest = PickFields<Session, 'title'> & {
  settings?: Partial<SessionSettings>;
};

export type UpdateSessionRequest = PartialUpdate<
  OmitFields<Session, 'id' | 'createdAt'>
>;

export type MessageWithoutId = OmitFields<Message, 'id'>;

export type RequiredMessage = RequiredFields<Message, 'content' | 'role'>;
```

### 条件类型和映射类型
```typescript
// types/advanced.ts

// 条件类型 - 根据角色确定消息类型
export type MessageByRole<T extends MessageRole> = 
  T extends MessageRole.USER 
    ? Message & { role: MessageRole.USER }
    : T extends MessageRole.ASSISTANT
    ? Message & { role: MessageRole.ASSISTANT; usage?: TokenUsage }
    : Message & { role: MessageRole.SYSTEM };

// 映射类型 - 创建只读版本
export type ReadonlyMessage = {
  readonly [K in keyof Message]: Message[K];
};

// 递归只读类型
export type DeepReadonly<T> = {
  readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];
};

// 函数重载类型
export interface SendMessageOverloads {
  (content: string): Promise<ChatResponse>;
  (content: string, sessionId: string): Promise<ChatResponse>;
  (content: string, sessionId: string, options: ChatOptions): Promise<ChatResponse>;
}

// 事件处理器类型
export type EventHandler<T> = (event: T) => void | Promise<void>;

export type ChatEventHandlers = {
  onMessageSent: EventHandler<Message>;
  onMessageReceived: EventHandler<Message>;
  onError: EventHandler<Error>;
  onSessionCreated: EventHandler<Session>;
};
```

### 泛型约束和索引类型
```typescript
// types/generic.ts

// 泛型约束
export interface Repository<T extends { id: string }> {
  findById(id: string): Promise<T | null>;
  create(data: Omit<T, 'id'>): Promise<T>;
  update(id: string, data: Partial<T>): Promise<T>;
  delete(id: string): Promise<void>;
  findAll(): Promise<T[]>;
}

// 消息仓库实现
export class MessageRepository implements Repository<Message> {
  async findById(id: string): Promise<Message | null> {
    // 实现逻辑
    return null;
  }

  async create(data: Omit<Message, 'id'>): Promise<Message> {
    const message: Message = {
      ...data,
      id: generateId(),
    };
    // 保存逻辑
    return message;
  }

  async update(id: string, data: Partial<Message>): Promise<Message> {
    // 更新逻辑
    throw new Error('Method not implemented.');
  }

  async delete(id: string): Promise<void> {
    // 删除逻辑
  }

  async findAll(): Promise<Message[]> {
    // 查询逻辑
    return [];
  }
}

// 索引类型
export type MessageKeys = keyof Message;
export type MessageValues = Message[MessageKeys];

// 根据键获取值类型
export type GetMessageValue<K extends MessageKeys> = Message[K];

// 过滤器类型
export type MessageFilter<T extends MessageKeys> = {
  [K in T]?: Message[K];
};

// 排序类型
export type SortDirection = 'asc' | 'desc';
export type MessageSort = {
  field: MessageKeys;
  direction: SortDirection;
};
```

---

## 🧪 类型测试和验证

### 类型测试工具
```typescript
// tests/types.test.ts

// 类型测试工具函数
type Expect<T extends true> = T;
type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
  ? true
  : false;

// 测试Message类型
type MessageTests = [
  Expect<Equal<Message['role'], MessageRole>>,
  Expect<Equal<Message['id'], string>>,
  Expect<Equal<Message['timestamp'], Date>>,
];

// 测试工具类型
type UtilityTests = [
  Expect<Equal<PartialUpdate<Message>, Partial<Message>>>,
  Expect<Equal<keyof RequiredFields<Message, 'content'>, keyof Message>>,
  Expect<Equal<OmitFields<Message, 'id'>['id'], never>>,
];

// 测试API响应类型
type ApiTests = [
  Expect<Equal<ChatResponse['success'], boolean>>,
  Expect<Equal<ChatResponse['data'], Message | undefined>>,
];

// 运行时类型验证测试
describe('Type Guards', () => {
  test('isValidMessage should validate message correctly', () => {
    const validMessage: Message = {
      id: '1',
      content: 'Hello',
      role: MessageRole.USER,
      timestamp: new Date(),
      sessionId: 'session-1',
    };

    expect(isValidMessage(validMessage)).toBe(true);
    expect(isValidMessage(null)).toBe(false);
    expect(isValidMessage({})).toBe(false);
    expect(isValidMessage({ id: 1 })).toBe(false);
  });

  test('MessageSchema should validate message structure', () => {
    const validData = {
      id: '1',
      content: 'Hello',
      role: 'user',
      timestamp: new Date(),
      sessionId: 'session-1',
    };

    expect(() => validateMessage(validData)).not.toThrow();
    expect(() => validateMessage({})).toThrow();
    expect(safeValidateMessage(validData)).toEqual(expect.objectContaining(validData));
    expect(safeValidateMessage({})).toBeNull();
  });
});
```

### 开发时类型检查
```typescript
// utils/devTypeChecks.ts

// 开发环境类型检查
export function assertType<T>(value: unknown, typeName: string): asserts value is T {
  if (process.env.NODE_ENV === 'development') {
    // 在开发环境进行额外的类型检查
    console.log(`Type assertion: ${typeName}`, value);
  }
}

// 类型安全的环境变量
export function getTypedEnvVar<T extends string | number | boolean>(
  name: string,
  defaultValue: T,
  type: 'string' | 'number' | 'boolean'
): T {
  const value = process.env[name];
  
  if (value === undefined) {
    return defaultValue;
  }
  
  switch (type) {
    case 'string':
      return value as T;
    case 'number':
      const num = Number(value);
      if (isNaN(num)) {
        console.warn(`Environment variable ${name} is not a valid number, using default`);
        return defaultValue;
      }
      return num as T;
    case 'boolean':
      return (value.toLowerCase() === 'true') as T;
    default:
      return defaultValue;
  }
}

// 使用示例
const apiTimeout = getTypedEnvVar('API_TIMEOUT', 5000, 'number');
const debugMode = getTypedEnvVar('DEBUG_MODE', false, 'boolean');
const apiUrl = getTypedEnvVar('API_URL', 'http://localhost:3000', 'string');
```

---

## 🔧 配置文件和工具集成

### ESLint TypeScript配置
```json
// eslint.config.mjs 的TypeScript部分
{
  "rules": {
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/prefer-const": "error",
    "@typescript-eslint/no-non-null-assertion": "warn",
    "@typescript-eslint/explicit-function-return-type": "off",
    "@typescript-eslint/explicit-module-boundary-types": "off",
    "@typescript-eslint/strict-boolean-expressions": "error",
    "@typescript-eslint/prefer-nullish-coalescing": "error",
    "@typescript-eslint/prefer-optional-chain": "error"
  }
}
```

### Prettier配置
```json
// .prettierrc
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "bracketSpacing": true,
  "arrowParens": "avoid"
}
```

### VS Code配置
```json
// .vscode/settings.json
{
  "typescript.preferences.includePackageJsonAutoImports": "on",
  "typescript.suggest.autoImports": true,
  "typescript.updateImportsOnFileMove.enabled": "always",
  "editor.codeActionsOnSave": {
    "source.organizeImports": true,
    "source.fixAll.eslint": true
  },
  "typescript.inlayHints.parameterNames.enabled": "all",
  "typescript.inlayHints.variableTypes.enabled": true,
  "typescript.inlayHints.functionLikeReturnTypes.enabled": true
}
```

---

## ✅ TypeScript应用总结

### 核心能力掌握
- ✅ **类型系统设计**：为复杂应用构建完整的类型体系
- ✅ **类型安全开发**：使用类型守卫和验证确保运行时安全
- ✅ **高级类型特性**：泛型、条件类型、映射类型的实际应用
- ✅ **API类型安全**：端到端的类型安全API交互

### 实战技能获得
- ✅ **React组件类型化**：Props、Hooks、事件处理的完整类型支持
- ✅ **错误处理类型化**：类型安全的错误处理和状态管理
- ✅ **工具链集成**：ESLint、Prettier、VS Code的TypeScript优化
- ✅ **测试类型支持**：类型测试和运行时验证策略

### 开发体验提升
- 🔍 **智能提示**：IDE提供精确的代码补全和导航
- 🛡️ **错误预防**：编译时发现潜在问题，减少调试时间
- 📖 **代码可读性**：自文档化的类型注解提升维护性
- 🔄 **重构支持**：安全的代码重构和批量修改

---

<!-- _class: lead -->
# 🎉 TypeScript实际应用完成！

## 现在拥有了类型安全的开发能力

**第3章前端基础全部完成！**
