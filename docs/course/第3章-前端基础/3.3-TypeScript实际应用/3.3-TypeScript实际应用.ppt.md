---
marp: true
theme: gaia
paginate: true
header: '3.3-TypeScriptå®é™…åº”ç”¨'
style: |
  section {
    font-size: 30px;
  }
---

<!-- _class: lead -->
# 3.3 TypeScriptå®é™…åº”ç”¨ ğŸ“˜

## æ„å»ºç±»å‹å®‰å…¨çš„AIèŠå¤©åº”ç”¨

**LangGraphæ™ºèƒ½èŠå¤©åº”ç”¨å¼€å‘æ•™ç¨‹**

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡æ¦‚è¿°

### æœ¬èŠ‚è¯¾çš„æ ¸å¿ƒä»·å€¼
- **ğŸ”’ æŒæ¡ç±»å‹å®‰å…¨å¼€å‘**ï¼šé¢„é˜²è¿è¡Œæ—¶é”™è¯¯ï¼Œæå‡ä»£ç è´¨é‡
- **ğŸ“– æå‡ä»£ç å¯è¯»æ€§**ï¼šè‡ªæ–‡æ¡£åŒ–çš„ç±»å‹æ³¨è§£å’Œæ¥å£å®šä¹‰
- **ğŸ› ï¸ ä¼˜åŒ–å¼€å‘ä½“éªŒ**ï¼šIDEæ™ºèƒ½æç¤ºã€è‡ªåŠ¨é‡æ„ã€é”™è¯¯æ£€æŸ¥
- **ğŸ—ï¸ æ„å»ºå¯ç»´æŠ¤ä»£ç **ï¼šæ¸…æ™°çš„ç±»å‹ç³»ç»Ÿæ”¯æ’‘å¤§å‹åº”ç”¨

### å…·ä½“å­¦ä¹ ç›®æ ‡
- ä¸ºAIèŠå¤©åº”ç”¨å®šä¹‰å®Œæ•´çš„ç±»å‹ç³»ç»Ÿ
- æŒæ¡TypeScripté«˜çº§ç±»å‹ç‰¹æ€§
- å®ç°ç±»å‹å®‰å…¨çš„APIäº¤äº’
- å­¦ä¼šæ³›å‹å’Œå·¥å…·ç±»å‹çš„å®é™…åº”ç”¨

---

## ğŸ“˜ TypeScriptæ ¸å¿ƒæ¦‚å¿µ

### ä¸ºä»€ä¹ˆé€‰æ‹©TypeScriptï¼Ÿ
```
ğŸ”’ ç±»å‹å®‰å…¨      âœ  ç¼–è¯‘æ—¶å‘ç°é”™è¯¯ï¼Œå‡å°‘è¿è¡Œæ—¶bug
ğŸ“š æ™ºèƒ½æç¤º      âœ  IDEæä¾›ç²¾ç¡®çš„ä»£ç è¡¥å…¨å’Œå¯¼èˆª
ğŸ”„ é‡æ„æ”¯æŒ      âœ  å®‰å…¨çš„ä»£ç é‡æ„å’Œæ‰¹é‡ä¿®æ”¹
ğŸ“– è‡ªæ–‡æ¡£åŒ–      âœ  ç±»å‹å³æ–‡æ¡£ï¼Œæå‡ä»£ç å¯è¯»æ€§
ğŸ‘¥ å›¢é˜Ÿåä½œ      âœ  ç»Ÿä¸€çš„ç±»å‹çº¦å®šï¼Œå‡å°‘æ²Ÿé€šæˆæœ¬
```

### TypeScript vs JavaScript
```typescript
// JavaScript - è¿è¡Œæ—¶æ‰å‘ç°é”™è¯¯
function sendMessage(content, sessionId) {
  return fetch('/api/chat', {
    method: 'POST',
    body: JSON.stringify({ content, sessionId })
  });
}

// TypeScript - ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥
function sendMessage(content: string, sessionId?: string): Promise<ChatResponse> {
  return fetch('/api/chat', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content, sessionId })
  }).then(res => res.json());
}
```

---

## ğŸ—ï¸ èŠå¤©åº”ç”¨ç±»å‹ç³»ç»Ÿè®¾è®¡

### åŸºç¡€æ•°æ®ç±»å‹å®šä¹‰
```typescript
// types/chat.ts

// æ¶ˆæ¯è§’è‰²æšä¸¾
export enum MessageRole {
  USER = 'user',
  ASSISTANT = 'assistant',
  SYSTEM = 'system'
}

// æ¶ˆæ¯æ¥å£
export interface Message {
  id: string;
  content: string;
  role: MessageRole;
  timestamp: Date;
  sessionId: string;
  metadata?: Record<string, unknown>;
  isLoading?: boolean;
  error?: string;
}

// ä¼šè¯æ¥å£
export interface Session {
  id: string;
  title: string;
  createdAt: Date;
  updatedAt: Date;
  messageCount: number;
  lastMessage?: string;
  settings?: SessionSettings;
}

// ä¼šè¯è®¾ç½®
export interface SessionSettings {
  temperature: number;
  maxTokens: number;
  model: string;
  systemPrompt?: string;
}
```

### APIå“åº”ç±»å‹
```typescript
// types/api.ts

// åŸºç¡€APIå“åº”
export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

// èŠå¤©APIå“åº”
export interface ChatResponse extends ApiResponse<Message> {
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
}

// ä¼šè¯åˆ—è¡¨å“åº”
export interface SessionListResponse extends ApiResponse<Session[]> {
  pagination?: {
    total: number;
    page: number;
    limit: number;
    hasNext: boolean;
  };
}

// æµå¼å“åº”äº‹ä»¶
export interface StreamEvent {
  type: 'start' | 'token' | 'end' | 'error';
  content?: string;
  error?: string;
  metadata?: Record<string, unknown>;
}
```

---

## ğŸ›¡ï¸ ç±»å‹å®ˆå«å’ŒéªŒè¯

### ç±»å‹å®ˆå«å‡½æ•°
```typescript
// utils/typeGuards.ts

// æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆæ¶ˆæ¯
export function isValidMessage(obj: unknown): obj is Message {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    typeof (obj as Message).id === 'string' &&
    typeof (obj as Message).content === 'string' &&
    Object.values(MessageRole).includes((obj as Message).role) &&
    (obj as Message).timestamp instanceof Date
  );
}

// æ£€æŸ¥APIå“åº”
export function isApiResponse<T>(obj: unknown): obj is ApiResponse<T> {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    typeof (obj as ApiResponse).success === 'boolean'
  );
}

// æ£€æŸ¥æµå¼äº‹ä»¶
export function isStreamEvent(obj: unknown): obj is StreamEvent {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    ['start', 'token', 'end', 'error'].includes((obj as StreamEvent).type)
  );
}

// ä½¿ç”¨ç¤ºä¾‹
function processApiResponse(response: unknown) {
  if (isApiResponse<Message>(response)) {
    if (response.success && response.data) {
      // TypeScriptçŸ¥é“response.dataæ˜¯Messageç±»å‹
      console.log(`æ”¶åˆ°æ¶ˆæ¯: ${response.data.content}`);
    } else {
      console.error(`APIé”™è¯¯: ${response.error}`);
    }
  }
}
```

### è¿è¡Œæ—¶éªŒè¯åº“é›†æˆ
```typescript
// utils/validation.ts
import { z } from 'zod';

// Zodæ¨¡å¼å®šä¹‰
export const MessageSchema = z.object({
  id: z.string(),
  content: z.string().min(1),
  role: z.enum(['user', 'assistant', 'system']),
  timestamp: z.date(),
  sessionId: z.string(),
  metadata: z.record(z.unknown()).optional(),
  isLoading: z.boolean().optional(),
  error: z.string().optional(),
});

export const SessionSchema = z.object({
  id: z.string(),
  title: z.string().min(1),
  createdAt: z.date(),
  updatedAt: z.date(),
  messageCount: z.number().min(0),
  lastMessage: z.string().optional(),
});

// ç±»å‹æ¨æ–­
export type Message = z.infer<typeof MessageSchema>;
export type Session = z.infer<typeof SessionSchema>;

// éªŒè¯å‡½æ•°
export function validateMessage(data: unknown): Message {
  return MessageSchema.parse(data);
}

export function safeValidateMessage(data: unknown): Message | null {
  const result = MessageSchema.safeParse(data);
  return result.success ? result.data : null;
}
```

---

## ğŸ”§ Reactç»„ä»¶ç±»å‹å®šä¹‰

### ç»„ä»¶Propsç±»å‹
```typescript
// components/ChatMessage.tsx
import { ReactNode } from 'react';

// åŸºç¡€Props
interface ChatMessageProps {
  message: Message;
  onEdit?: (messageId: string, newContent: string) => void;
  onDelete?: (messageId: string) => void;
  onRegenerate?: (messageId: string) => void;
  className?: string;
  children?: ReactNode;
}

// ä½¿ç”¨æ³›å‹çš„Props
interface ListProps<T> {
  items: T[];
  renderItem: (item: T, index: number) => ReactNode;
  keyExtractor: (item: T) => string;
  loading?: boolean;
  emptyMessage?: string;
}

// ç»„ä»¶å®ç°
export function ChatMessage({ 
  message, 
  onEdit, 
  onDelete, 
  onRegenerate,
  className = '',
  children 
}: ChatMessageProps) {
  const isUser = message.role === MessageRole.USER;
  
  return (
    <div className={`message ${isUser ? 'user' : 'assistant'} ${className}`}>
      <div className="message-content">
        {message.content}
      </div>
      {children}
      <div className="message-actions">
        {onEdit && (
          <button onClick={() => onEdit(message.id, message.content)}>
            ç¼–è¾‘
          </button>
        )}
        {onDelete && (
          <button onClick={() => onDelete(message.id)}>
            åˆ é™¤
          </button>
        )}
        {onRegenerate && message.role === MessageRole.ASSISTANT && (
          <button onClick={() => onRegenerate(message.id)}>
            é‡æ–°ç”Ÿæˆ
          </button>
        )}
      </div>
    </div>
  );
}
```

### Hooksç±»å‹å®šä¹‰
```typescript
// hooks/useChat.ts
import { useState, useCallback, useRef } from 'react';

// Hookè¿”å›ç±»å‹
interface UseChatReturn {
  messages: Message[];
  isLoading: boolean;
  error: string | null;
  sendMessage: (content: string) => Promise<void>;
  editMessage: (messageId: string, newContent: string) => Promise<void>;
  deleteMessage: (messageId: string) => void;
  clearMessages: () => void;
  retryLastMessage: () => Promise<void>;
}

// Hooké€‰é¡¹ç±»å‹
interface UseChatOptions {
  sessionId?: string;
  onError?: (error: Error) => void;
  onMessageReceived?: (message: Message) => void;
  autoScroll?: boolean;
}

export function useChat(options: UseChatOptions = {}): UseChatReturn {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const abortControllerRef = useRef<AbortController | null>(null);

  const sendMessage = useCallback(async (content: string) => {
    if (!content.trim() || isLoading) return;

    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
    const userMessage: Message = {
      id: `user-${Date.now()}`,
      content: content.trim(),
      role: MessageRole.USER,
      timestamp: new Date(),
      sessionId: options.sessionId || 'default',
    };

    setMessages(prev => [...prev, userMessage]);
    setIsLoading(true);
    setError(null);

    // å–æ¶ˆä¹‹å‰çš„è¯·æ±‚
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    const abortController = new AbortController();
    abortControllerRef.current = abortController;

    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: content,
          sessionId: options.sessionId,
        }),
        signal: abortController.signal,
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const result: ChatResponse = await response.json();
      
      if (result.success && result.data) {
        setMessages(prev => [...prev, result.data!]);
        options.onMessageReceived?.(result.data);
      } else {
        throw new Error(result.error || 'å‘é€æ¶ˆæ¯å¤±è´¥');
      }
    } catch (err) {
      if (err instanceof Error && err.name === 'AbortError') {
        return; // è¯·æ±‚è¢«å–æ¶ˆï¼Œä¸å¤„ç†
      }
      
      const errorMessage = err instanceof Error ? err.message : 'æœªçŸ¥é”™è¯¯';
      setError(errorMessage);
      options.onError?.(err instanceof Error ? err : new Error(errorMessage));
    } finally {
      setIsLoading(false);
      abortControllerRef.current = null;
    }
  }, [isLoading, options]);

  const editMessage = useCallback(async (messageId: string, newContent: string) => {
    // ç¼–è¾‘æ¶ˆæ¯é€»è¾‘
    setMessages(prev => 
      prev.map(msg => 
        msg.id === messageId 
          ? { ...msg, content: newContent, updatedAt: new Date() }
          : msg
      )
    );
  }, []);

  const deleteMessage = useCallback((messageId: string) => {
    setMessages(prev => prev.filter(msg => msg.id !== messageId));
  }, []);

  const clearMessages = useCallback(() => {
    setMessages([]);
    setError(null);
  }, []);

  const retryLastMessage = useCallback(async () => {
    const lastUserMessage = messages
      .filter(msg => msg.role === MessageRole.USER)
      .pop();
    
    if (lastUserMessage) {
      await sendMessage(lastUserMessage.content);
    }
  }, [messages, sendMessage]);

  return {
    messages,
    isLoading,
    error,
    sendMessage,
    editMessage,
    deleteMessage,
    clearMessages,
    retryLastMessage,
  };
}
```

---

## ğŸŒ APIå®¢æˆ·ç«¯ç±»å‹å®‰å…¨

### APIå®¢æˆ·ç«¯ç±»
```typescript
// utils/apiClient.ts

// APIé…ç½®
interface ApiConfig {
  baseUrl: string;
  timeout: number;
  headers?: Record<string, string>;
}

// APIé”™è¯¯ç±»
export class ApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public response?: unknown
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

// APIå®¢æˆ·ç«¯ç±»
export class ChatApiClient {
  private config: ApiConfig;

  constructor(config: Partial<ApiConfig> = {}) {
    this.config = {
      baseUrl: '/api',
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
      },
      ...config,
    };
  }

  // é€šç”¨è¯·æ±‚æ–¹æ³•
  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.config.baseUrl}${endpoint}`;
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);

    try {
      const response = await fetch(url, {
        ...options,
        headers: {
          ...this.config.headers,
          ...options.headers,
        },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorData = await response.json().catch(() => null);
        throw new ApiError(
          errorData?.error || `HTTP ${response.status}`,
          response.status,
          errorData
        );
      }

      return response.json();
    } catch (error) {
      clearTimeout(timeoutId);
      
      if (error instanceof ApiError) {
        throw error;
      }
      
      throw new ApiError(
        error instanceof Error ? error.message : 'ç½‘ç»œè¯·æ±‚å¤±è´¥',
        0
      );
    }
  }

  // å‘é€æ¶ˆæ¯
  async sendMessage(content: string, sessionId?: string): Promise<ChatResponse> {
    return this.request<ChatResponse>('/chat', {
      method: 'POST',
      body: JSON.stringify({ message: content, sessionId }),
    });
  }

  // è·å–ä¼šè¯åˆ—è¡¨
  async getSessions(): Promise<SessionListResponse> {
    return this.request<SessionListResponse>('/sessions');
  }

  // åˆ›å»ºæ–°ä¼šè¯
  async createSession(title?: string): Promise<ApiResponse<Session>> {
    return this.request<ApiResponse<Session>>('/sessions', {
      method: 'POST',
      body: JSON.stringify({ title }),
    });
  }

  // è·å–ä¼šè¯è¯¦æƒ…
  async getSession(sessionId: string): Promise<ApiResponse<Session>> {
    return this.request<ApiResponse<Session>>(`/sessions/${sessionId}`);
  }

  // åˆ é™¤ä¼šè¯
  async deleteSession(sessionId: string): Promise<ApiResponse> {
    return this.request<ApiResponse>(`/sessions/${sessionId}`, {
      method: 'DELETE',
    });
  }

  // æµå¼èŠå¤©
  async *streamChat(content: string, sessionId?: string): AsyncGenerator<StreamEvent> {
    const response = await fetch(`${this.config.baseUrl}/chat/stream`, {
      method: 'POST',
      headers: this.config.headers,
      body: JSON.stringify({ message: content, sessionId }),
    });

    if (!response.ok) {
      throw new ApiError(`HTTP ${response.status}`, response.status);
    }

    const reader = response.body?.getReader();
    if (!reader) {
      throw new ApiError('æ— æ³•è¯»å–å“åº”æµ', 0);
    }

    const decoder = new TextDecoder();
    let buffer = '';

    try {
      while (true) {
        const { done, value } = await reader.read();
        
        if (done) break;
        
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const data = JSON.parse(line.slice(6));
              if (isStreamEvent(data)) {
                yield data;
              }
            } catch (error) {
              console.warn('è§£ææµæ•°æ®å¤±è´¥:', error);
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }
}

// åˆ›å»ºAPIå®¢æˆ·ç«¯å®ä¾‹
export const apiClient = new ChatApiClient();
```

---

## ğŸ”§ é«˜çº§ç±»å‹ç‰¹æ€§åº”ç”¨

### å·¥å…·ç±»å‹ä½¿ç”¨
```typescript
// types/utils.ts

// éƒ¨åˆ†æ›´æ–°ç±»å‹
export type PartialUpdate<T> = Partial<Pick<T, keyof T>>;

// å¿…éœ€å­—æ®µç±»å‹
export type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>;

// æ’é™¤å­—æ®µç±»å‹
export type OmitFields<T, K extends keyof T> = Omit<T, K>;

// æå–å­—æ®µç±»å‹
export type PickFields<T, K extends keyof T> = Pick<T, K>;

// å®é™…åº”ç”¨ç¤ºä¾‹
export type CreateSessionRequest = PickFields<Session, 'title'> & {
  settings?: Partial<SessionSettings>;
};

export type UpdateSessionRequest = PartialUpdate<
  OmitFields<Session, 'id' | 'createdAt'>
>;

export type MessageWithoutId = OmitFields<Message, 'id'>;

export type RequiredMessage = RequiredFields<Message, 'content' | 'role'>;
```

### æ¡ä»¶ç±»å‹å’Œæ˜ å°„ç±»å‹
```typescript
// types/advanced.ts

// æ¡ä»¶ç±»å‹ - æ ¹æ®è§’è‰²ç¡®å®šæ¶ˆæ¯ç±»å‹
export type MessageByRole<T extends MessageRole> = 
  T extends MessageRole.USER 
    ? Message & { role: MessageRole.USER }
    : T extends MessageRole.ASSISTANT
    ? Message & { role: MessageRole.ASSISTANT; usage?: TokenUsage }
    : Message & { role: MessageRole.SYSTEM };

// æ˜ å°„ç±»å‹ - åˆ›å»ºåªè¯»ç‰ˆæœ¬
export type ReadonlyMessage = {
  readonly [K in keyof Message]: Message[K];
};

// é€’å½’åªè¯»ç±»å‹
export type DeepReadonly<T> = {
  readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];
};

// å‡½æ•°é‡è½½ç±»å‹
export interface SendMessageOverloads {
  (content: string): Promise<ChatResponse>;
  (content: string, sessionId: string): Promise<ChatResponse>;
  (content: string, sessionId: string, options: ChatOptions): Promise<ChatResponse>;
}

// äº‹ä»¶å¤„ç†å™¨ç±»å‹
export type EventHandler<T> = (event: T) => void | Promise<void>;

export type ChatEventHandlers = {
  onMessageSent: EventHandler<Message>;
  onMessageReceived: EventHandler<Message>;
  onError: EventHandler<Error>;
  onSessionCreated: EventHandler<Session>;
};
```

### æ³›å‹çº¦æŸå’Œç´¢å¼•ç±»å‹
```typescript
// types/generic.ts

// æ³›å‹çº¦æŸ
export interface Repository<T extends { id: string }> {
  findById(id: string): Promise<T | null>;
  create(data: Omit<T, 'id'>): Promise<T>;
  update(id: string, data: Partial<T>): Promise<T>;
  delete(id: string): Promise<void>;
  findAll(): Promise<T[]>;
}

// æ¶ˆæ¯ä»“åº“å®ç°
export class MessageRepository implements Repository<Message> {
  async findById(id: string): Promise<Message | null> {
    // å®ç°é€»è¾‘
    return null;
  }

  async create(data: Omit<Message, 'id'>): Promise<Message> {
    const message: Message = {
      ...data,
      id: generateId(),
    };
    // ä¿å­˜é€»è¾‘
    return message;
  }

  async update(id: string, data: Partial<Message>): Promise<Message> {
    // æ›´æ–°é€»è¾‘
    throw new Error('Method not implemented.');
  }

  async delete(id: string): Promise<void> {
    // åˆ é™¤é€»è¾‘
  }

  async findAll(): Promise<Message[]> {
    // æŸ¥è¯¢é€»è¾‘
    return [];
  }
}

// ç´¢å¼•ç±»å‹
export type MessageKeys = keyof Message;
export type MessageValues = Message[MessageKeys];

// æ ¹æ®é”®è·å–å€¼ç±»å‹
export type GetMessageValue<K extends MessageKeys> = Message[K];

// è¿‡æ»¤å™¨ç±»å‹
export type MessageFilter<T extends MessageKeys> = {
  [K in T]?: Message[K];
};

// æ’åºç±»å‹
export type SortDirection = 'asc' | 'desc';
export type MessageSort = {
  field: MessageKeys;
  direction: SortDirection;
};
```

---

## ğŸ§ª ç±»å‹æµ‹è¯•å’ŒéªŒè¯

### ç±»å‹æµ‹è¯•å·¥å…·
```typescript
// tests/types.test.ts

// ç±»å‹æµ‹è¯•å·¥å…·å‡½æ•°
type Expect<T extends true> = T;
type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2
  ? true
  : false;

// æµ‹è¯•Messageç±»å‹
type MessageTests = [
  Expect<Equal<Message['role'], MessageRole>>,
  Expect<Equal<Message['id'], string>>,
  Expect<Equal<Message['timestamp'], Date>>,
];

// æµ‹è¯•å·¥å…·ç±»å‹
type UtilityTests = [
  Expect<Equal<PartialUpdate<Message>, Partial<Message>>>,
  Expect<Equal<keyof RequiredFields<Message, 'content'>, keyof Message>>,
  Expect<Equal<OmitFields<Message, 'id'>['id'], never>>,
];

// æµ‹è¯•APIå“åº”ç±»å‹
type ApiTests = [
  Expect<Equal<ChatResponse['success'], boolean>>,
  Expect<Equal<ChatResponse['data'], Message | undefined>>,
];

// è¿è¡Œæ—¶ç±»å‹éªŒè¯æµ‹è¯•
describe('Type Guards', () => {
  test('isValidMessage should validate message correctly', () => {
    const validMessage: Message = {
      id: '1',
      content: 'Hello',
      role: MessageRole.USER,
      timestamp: new Date(),
      sessionId: 'session-1',
    };

    expect(isValidMessage(validMessage)).toBe(true);
    expect(isValidMessage(null)).toBe(false);
    expect(isValidMessage({})).toBe(false);
    expect(isValidMessage({ id: 1 })).toBe(false);
  });

  test('MessageSchema should validate message structure', () => {
    const validData = {
      id: '1',
      content: 'Hello',
      role: 'user',
      timestamp: new Date(),
      sessionId: 'session-1',
    };

    expect(() => validateMessage(validData)).not.toThrow();
    expect(() => validateMessage({})).toThrow();
    expect(safeValidateMessage(validData)).toEqual(expect.objectContaining(validData));
    expect(safeValidateMessage({})).toBeNull();
  });
});
```

### å¼€å‘æ—¶ç±»å‹æ£€æŸ¥
```typescript
// utils/devTypeChecks.ts

// å¼€å‘ç¯å¢ƒç±»å‹æ£€æŸ¥
export function assertType<T>(value: unknown, typeName: string): asserts value is T {
  if (process.env.NODE_ENV === 'development') {
    // åœ¨å¼€å‘ç¯å¢ƒè¿›è¡Œé¢å¤–çš„ç±»å‹æ£€æŸ¥
    console.log(`Type assertion: ${typeName}`, value);
  }
}

// ç±»å‹å®‰å…¨çš„ç¯å¢ƒå˜é‡
export function getTypedEnvVar<T extends string | number | boolean>(
  name: string,
  defaultValue: T,
  type: 'string' | 'number' | 'boolean'
): T {
  const value = process.env[name];
  
  if (value === undefined) {
    return defaultValue;
  }
  
  switch (type) {
    case 'string':
      return value as T;
    case 'number':
      const num = Number(value);
      if (isNaN(num)) {
        console.warn(`Environment variable ${name} is not a valid number, using default`);
        return defaultValue;
      }
      return num as T;
    case 'boolean':
      return (value.toLowerCase() === 'true') as T;
    default:
      return defaultValue;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const apiTimeout = getTypedEnvVar('API_TIMEOUT', 5000, 'number');
const debugMode = getTypedEnvVar('DEBUG_MODE', false, 'boolean');
const apiUrl = getTypedEnvVar('API_URL', 'http://localhost:3000', 'string');
```

---

## ğŸ”§ é…ç½®æ–‡ä»¶å’Œå·¥å…·é›†æˆ

### ESLint TypeScripté…ç½®
```json
// eslint.config.mjs çš„TypeScriptéƒ¨åˆ†
{
  "rules": {
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/prefer-const": "error",
    "@typescript-eslint/no-non-null-assertion": "warn",
    "@typescript-eslint/explicit-function-return-type": "off",
    "@typescript-eslint/explicit-module-boundary-types": "off",
    "@typescript-eslint/strict-boolean-expressions": "error",
    "@typescript-eslint/prefer-nullish-coalescing": "error",
    "@typescript-eslint/prefer-optional-chain": "error"
  }
}
```

### Prettieré…ç½®
```json
// .prettierrc
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "bracketSpacing": true,
  "arrowParens": "avoid"
}
```

### VS Codeé…ç½®
```json
// .vscode/settings.json
{
  "typescript.preferences.includePackageJsonAutoImports": "on",
  "typescript.suggest.autoImports": true,
  "typescript.updateImportsOnFileMove.enabled": "always",
  "editor.codeActionsOnSave": {
    "source.organizeImports": true,
    "source.fixAll.eslint": true
  },
  "typescript.inlayHints.parameterNames.enabled": "all",
  "typescript.inlayHints.variableTypes.enabled": true,
  "typescript.inlayHints.functionLikeReturnTypes.enabled": true
}
```

---

## âœ… TypeScriptåº”ç”¨æ€»ç»“

### æ ¸å¿ƒèƒ½åŠ›æŒæ¡
- âœ… **ç±»å‹ç³»ç»Ÿè®¾è®¡**ï¼šä¸ºå¤æ‚åº”ç”¨æ„å»ºå®Œæ•´çš„ç±»å‹ä½“ç³»
- âœ… **ç±»å‹å®‰å…¨å¼€å‘**ï¼šä½¿ç”¨ç±»å‹å®ˆå«å’ŒéªŒè¯ç¡®ä¿è¿è¡Œæ—¶å®‰å…¨
- âœ… **é«˜çº§ç±»å‹ç‰¹æ€§**ï¼šæ³›å‹ã€æ¡ä»¶ç±»å‹ã€æ˜ å°„ç±»å‹çš„å®é™…åº”ç”¨
- âœ… **APIç±»å‹å®‰å…¨**ï¼šç«¯åˆ°ç«¯çš„ç±»å‹å®‰å…¨APIäº¤äº’

### å®æˆ˜æŠ€èƒ½è·å¾—
- âœ… **Reactç»„ä»¶ç±»å‹åŒ–**ï¼šPropsã€Hooksã€äº‹ä»¶å¤„ç†çš„å®Œæ•´ç±»å‹æ”¯æŒ
- âœ… **é”™è¯¯å¤„ç†ç±»å‹åŒ–**ï¼šç±»å‹å®‰å…¨çš„é”™è¯¯å¤„ç†å’ŒçŠ¶æ€ç®¡ç†
- âœ… **å·¥å…·é“¾é›†æˆ**ï¼šESLintã€Prettierã€VS Codeçš„TypeScriptä¼˜åŒ–
- âœ… **æµ‹è¯•ç±»å‹æ”¯æŒ**ï¼šç±»å‹æµ‹è¯•å’Œè¿è¡Œæ—¶éªŒè¯ç­–ç•¥

### å¼€å‘ä½“éªŒæå‡
- ğŸ” **æ™ºèƒ½æç¤º**ï¼šIDEæä¾›ç²¾ç¡®çš„ä»£ç è¡¥å…¨å’Œå¯¼èˆª
- ğŸ›¡ï¸ **é”™è¯¯é¢„é˜²**ï¼šç¼–è¯‘æ—¶å‘ç°æ½œåœ¨é—®é¢˜ï¼Œå‡å°‘è°ƒè¯•æ—¶é—´
- ğŸ“– **ä»£ç å¯è¯»æ€§**ï¼šè‡ªæ–‡æ¡£åŒ–çš„ç±»å‹æ³¨è§£æå‡ç»´æŠ¤æ€§
- ğŸ”„ **é‡æ„æ”¯æŒ**ï¼šå®‰å…¨çš„ä»£ç é‡æ„å’Œæ‰¹é‡ä¿®æ”¹

---

<!-- _class: lead -->
# ğŸ‰ TypeScriptå®é™…åº”ç”¨å®Œæˆï¼

## ç°åœ¨æ‹¥æœ‰äº†ç±»å‹å®‰å…¨çš„å¼€å‘èƒ½åŠ›

**ç¬¬3ç« å‰ç«¯åŸºç¡€å…¨éƒ¨å®Œæˆï¼**
