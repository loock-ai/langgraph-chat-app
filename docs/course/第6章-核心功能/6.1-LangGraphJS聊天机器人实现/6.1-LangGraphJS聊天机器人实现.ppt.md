---
marp: true
theme: gaia
paginate: true
header: '6.1-LangGraphJS聊天机器人实现'
style: |
  section {
    font-size: 30px;
  }
---

<!-- _class: lead -->
# 第6章 核心功能 🔧

## 6.1 LangGraphJS聊天机器人实现

**构建智能对话的AI核心**

---

## 🎯 学习目标

- **构建完整的LangGraphJS聊天机器人核心逻辑**
- **实现StateGraph工作流和chatbot节点**
- **配置检查点持久化和会话管理**
- **集成OpenAI API实现智能对话**

打造聊天应用的智能大脑！

---

## 📚 聊天机器人架构设计

### 核心组件关系
```
StateGraph (状态图)
    ↓
chatbotNode (聊天节点) → OpenAI API
    ↓
MessagesAnnotation (状态管理)
    ↓
SqliteSaver (检查点持久化)
```

### 工作流设计
**START** → **chatbot** → **END**
- 单一节点设计，专注对话功能
- 支持流式响应和状态持久化

---

## 💡 chatbot节点核心实现

```typescript
async function chatbotNode(state: typeof MessagesAnnotation.State) {
  try {
    console.log(`处理消息: ${state.messages.length}条历史消息`);
    
    // 调用OpenAI模型生成回复
    const response = await model.invoke(state.messages);
    
    console.log(`AI回复长度: ${response.content.length}字符`);
    
    // 返回新的消息，LangGraph会自动合并到状态中
    return { messages: [response] };
    
  } catch (error) {
    console.error('chatbot节点处理错误:', error);
    
    // 返回错误消息
    const errorMessage = new AIMessage('抱歉，我暂时无法回复。请稍后重试。');
    return { messages: [errorMessage] };
  }
}
```

---

## 🔗 StateGraph工作流构建

```typescript
// 创建LangGraph状态图工作流
const workflow = new StateGraph(MessagesAnnotation)
  .addNode('chatbot', chatbotNode)
  .addEdge(START, 'chatbot')
  .addEdge('chatbot', END);

console.log('StateGraph工作流创建完成');
```

### 工作流特点
- **简洁高效** - 单节点设计专注对话
- **可扩展** - 易于添加新的节点和功能
- **状态管理** - 自动处理消息状态

---

## 🔗 检查点持久化配置

```typescript
// 配置SQLite检查点保存器
try {
  const checkpointer = new SqliteSaver(db);
  console.log('SQLite检查点保存器创建成功');
  
  // 编译应用，添加检查点支持
  const app = workflow.compile({ checkpointer });
  console.log('LangGraph应用编译完成，支持状态持久化');
  
  // 导出编译后的应用
  export { app, chatbotNode };
  
} catch (error) {
  console.error('检查点配置失败:', error);
  throw new Error('LangGraph应用初始化失败');
}
```

---

## 🌟 OpenAI模型配置

```typescript
// app/agent/config/tools.config.ts
import { ChatOpenAI } from '@langchain/openai';

export const model = new ChatOpenAI({
  model: process.env.OPENAI_MODEL_NAME || "qwen-plus",
  temperature: 0.7,
  maxTokens: 2000,
  streaming: true,
  openAIApiKey: process.env.OPENAI_API_KEY,
});

// 模型配置验证
if (!process.env.OPENAI_API_KEY) {
  throw new Error('缺少OPENAI_API_KEY环境变量');
}
```

合理的模型配置是AI对话质量的保证！

---

## 🔧 错误处理和容错

```typescript
async function robustChatbotNode(state: typeof MessagesAnnotation.State) {
  const maxRetries = 3;
  let lastError: any;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await model.invoke(state.messages);
      return { messages: [response] };
      
    } catch (error) {
      console.error(`chatbot节点错误 (尝试 ${attempt}):`, error);
      lastError = error;
      
      if (attempt < maxRetries) {
        // 指数退避
        const delay = Math.pow(2, attempt) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  // 所有重试都失败，返回错误消息
  const errorMessage = new AIMessage('抱歉，AI服务暂时不可用。请稍后重试。');
  return { messages: [errorMessage] };
}
```

---

## 🔧 测试和验证

```typescript
// 测试聊天功能
export async function testChatbot() {
  const testThreadId = 'test-session-' + Date.now();
  
  try {
    console.log('开始测试聊天机器人...');
    
    // 测试单轮对话
    const response = await app.invoke(
      { messages: [new HumanMessage('你好，请介绍一下自己')] },
      { configurable: { thread_id: testThreadId } }
    );
    
    console.log('AI回复:', response.messages[response.messages.length - 1].content);
    
    // 测试状态持久化
    const savedState = await app.getState({
      configurable: { thread_id: testThreadId }
    });
    
    console.log('状态保存成功，消息数量:', savedState?.values?.messages?.length);
    
    return true;
    
  } catch (error) {
    console.error('聊天机器人测试失败:', error);
    return false;
  }
}
```

---

## 📋 总结要点

- **StateGraph架构** - 简洁的单节点工作流设计
- **chatbot节点** - 核心的AI对话处理逻辑
- **检查点持久化** - 自动的状态保存和恢复
- **错误处理** - 健壮的容错和重试机制
- **模型集成** - OpenAI API的深度集成

LangGraphJS让AI应用开发更加专业！

---

## 🚀 下一步预告

完成了聊天机器人核心实现后，我们将学习：

**6.2 API路由完善**
- 流式响应API接口实现
- 历史记录获取和会话管理
- 健壮的错误处理机制
- 生产级API接口设计

将AI引擎与前端无缝连接！

