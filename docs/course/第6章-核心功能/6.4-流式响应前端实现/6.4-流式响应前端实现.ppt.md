---
marp: true
theme: gaia
paginate: true
header: '6.4-æµå¼å“åº”å‰ç«¯å®ç°'
style: |
  section {
    font-size: 30px;
  }
---

<!-- _class: lead -->
# ç¬¬6ç«  æ ¸å¿ƒåŠŸèƒ½ ğŸ”§

## 6.4 æµå¼å“åº”å‰ç«¯å®ç°

**æ‰“é€ å¦‚ä¸èˆ¬é¡ºæ»‘çš„AIå¯¹è¯ä½“éªŒ**

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

- **æŒæ¡å‰ç«¯æµå¼æ•°æ®æ¥æ”¶å’Œå¤„ç†æŠ€æœ¯**
- **å®ç°æµç•…çš„æ‰“å­—æœºæ•ˆæœå’Œå®æ—¶æ˜¾ç¤º**
- **ä¼˜åŒ–æµå¼å“åº”çš„æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒ**
- **å»ºç«‹å¥å£®çš„æµå¼é”™è¯¯å¤„ç†æœºåˆ¶**

è®©AIå¯¹è¯å¦‚ä¸èˆ¬é¡ºæ»‘ï¼

---

## ğŸ“š æµå¼å“åº”å‰ç«¯æ¶æ„

### æµå¼å¤„ç†æµç¨‹
```
APIè¯·æ±‚ â†’ ReadableStream â†’ æ•°æ®è§£æ â†’ çŠ¶æ€æ›´æ–° â†’ UIæ¸²æŸ“
    â†“           â†“           â†“          â†“         â†“
å‘é€æ¶ˆæ¯     æ¥æ”¶æ•°æ®å—     JSONè§£æ    æ¶ˆæ¯æ›´æ–°   æ‰“å­—æœºæ•ˆæœ
```

### æ ¸å¿ƒæŠ€æœ¯æ ˆ
- **ReadableStream API** - æµè§ˆå™¨åŸç”Ÿæµå¼æ•°æ®å¤„ç†
- **TextDecoder** - äºŒè¿›åˆ¶æ•°æ®è§£ç 
- **ReactçŠ¶æ€ç®¡ç†** - å®æ—¶UIæ›´æ–°
- **JSONæµè§£æ** - ç»“æ„åŒ–æ•°æ®å¤„ç†

---

## ğŸ’¡ æ ¸å¿ƒæµå¼å“åº”Hook

```typescript
export function useStreamingChat({ sessionId, onMessageUpdate, onError }) {
  const [isLoading, setIsLoading] = useState(false);
  const [streamingMessageId, setStreamingMessageId] = useState<string | null>(null);
  const abortControllerRef = useRef<AbortController | null>(null);

  const sendStreamingMessage = useCallback(async (content: string) => {
    // å–æ¶ˆä¹‹å‰çš„è¯·æ±‚
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    abortControllerRef.current = new AbortController();

    // åˆ›å»ºç”¨æˆ·æ¶ˆæ¯å’ŒAIæ¶ˆæ¯å ä½ç¬¦
    const userMessage = { /* ... */ };
    const assistantMessage = { /* ... */ };
    
    updateMessages(prev => [...prev, userMessage, assistantMessage]);
    setStreamingMessageId(assistantMessage.id);

    try {
      await processStreamingResponse(content, assistantMessage.id);
    } catch (error) {
      // é”™è¯¯å¤„ç†...
    } finally {
      setIsLoading(false);
      setStreamingMessageId(null);
    }
  }, [sessionId, onMessageUpdate, onError]);

  return { isLoading, streamingMessageId, sendStreamingMessage };
}
```

---

## ğŸ”— æµå¼æ•°æ®å¤„ç†æ ¸å¿ƒ

```typescript
const processStreamingResponse = async (message: string, messageId: string) => {
  const response = await fetch('/api/chat', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ message, threadId: sessionId }),
    signal: abortControllerRef.current?.signal
  });

  const reader = response.body?.getReader();
  const decoder = new TextDecoder();
  let buffer = '';

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    // è§£ç æ•°æ®å—
    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';

    // å¤„ç†æ¯ä¸€è¡Œæ•°æ®
    for (const line of lines) {
      if (line.trim()) {
        const event = JSON.parse(line);
        await handleStreamEvent(event, messageId);
      }
    }
  }
};
```

---

## ğŸ”— æµå¼äº‹ä»¶å¤„ç†

```typescript
const handleStreamEvent = async (event: StreamEvent, messageId: string) => {
  switch (event.type) {
    case 'start':
      console.log('æµå¼å“åº”å¼€å§‹:', event.timestamp);
      break;

    case 'chunk':
      if (event.content) {
        // æ›´æ–°æ¶ˆæ¯å†…å®¹ï¼ˆæ·»åŠ æ–°çš„å†…å®¹å—ï¼‰
        updateMessages(prev => prev.map(msg =>
          msg.id === messageId
            ? { ...msg, content: msg.content + event.content }
            : msg
        ));
        
        // æ·»åŠ è½»å¾®å»¶è¿Ÿåˆ›é€ æ›´è‡ªç„¶çš„æ‰“å­—æ•ˆæœ
        await new Promise(resolve => setTimeout(resolve, 20));
      }
      break;

    case 'end':
      // æ ‡è®°æµå¼å“åº”ç»“æŸ
      updateMessages(prev => prev.map(msg =>
        msg.id === messageId
          ? { ...msg, isStreaming: false }
          : msg
      ));
      break;

    case 'error':
      throw new Error(event.message || 'æµå¼å“åº”é”™è¯¯');
  }
};
```

---

## ğŸŒŸ å¢å¼ºçš„èŠå¤©è¾“å…¥ç»„ä»¶

```typescript
export default function ChatInput({ 
  onSendMessage, 
  disabled = false,
  showStopButton = false,
  onStop
}) {
  return (
    <div className="border-t bg-white px-4 py-4">
      <div className="flex items-end space-x-3">
        <textarea
          value={input}
          onChange={handleInputChange}
          onKeyPress={handleKeyPress}
          placeholder={placeholder}
          disabled={disabled && !showStopButton}
          className="flex-1 px-4 py-3 border rounded-2xl resize-none focus:ring-2 focus:ring-blue-500"
        />
        
        {/* å‘é€/åœæ­¢æŒ‰é’® */}
        <button
          onClick={showStopButton ? onStop : handleSend}
          className={`w-12 h-12 rounded-full transition-all duration-200 ${
            showStopButton
              ? 'bg-red-500 hover:bg-red-600 text-white'
              : 'bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 text-white'
          }`}
        >
          {showStopButton ? 'â¹ï¸' : 'ğŸ“¤'}
        </button>
      </div>
      
      {/* åŠ¨æ€æç¤ºæ–‡å­— */}
      <div className="mt-2 text-xs text-gray-500 text-center">
        {showStopButton ? (
          <span className="text-red-500">æŒ‰ Enter æˆ–ç‚¹å‡»æŒ‰é’®åœæ­¢ç”Ÿæˆ</span>
        ) : (
          'æŒ‰ Enter å‘é€ï¼ŒShift + Enter æ¢è¡Œ'
        )}
      </div>
    </div>
  );
}
```

---

## ğŸ”§ æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### æµå¼å“åº”æ€§èƒ½ç›‘æ§
```typescript
export class StreamingMonitor {
  private startTime: number = 0;
  private chunkCount: number = 0;
  private totalBytes: number = 0;

  start() {
    this.startTime = Date.now();
    this.chunkCount = 0;
    this.totalBytes = 0;
  }

  recordChunk(content: string) {
    this.chunkCount++;
    this.totalBytes += new Blob([content]).size;
  }

  end() {
    const totalTime = Date.now() - this.startTime;
    return {
      totalTime,
      chunkCount: this.chunkCount,
      totalBytes: this.totalBytes,
      throughput: this.totalBytes / (totalTime / 1000), // bytes/second
      chunksPerSecond: this.chunkCount / (totalTime / 1000)
    };
  }
}
```

---

## ğŸ”§ é”™è¯¯æ¢å¤æœºåˆ¶

### ç½‘ç»œçŠ¶æ€ç›‘æ§
```typescript
const useNetworkStatus = () => {
  const [isOnline, setIsOnline] = useState(navigator.onLine);

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return isOnline;
};

// åœ¨æµå¼å¤„ç†ä¸­ä½¿ç”¨
const processStreamingResponse = async (message: string, messageId: string) => {
  try {
    // ... æµå¼å¤„ç†é€»è¾‘
  } catch (error) {
    if (error.name === 'AbortError') {
      console.log('æµå¼è¯·æ±‚è¢«ç”¨æˆ·å–æ¶ˆ');
    } else if (!navigator.onLine) {
      throw new Error('ç½‘ç»œè¿æ¥ä¸­æ–­ï¼Œè¯·æ£€æŸ¥ç½‘ç»œåé‡è¯•');
    } else {
      throw error;
    }
  }
};
```

---

## ğŸ”§ è°ƒè¯•å’Œä¼˜åŒ–

### å¼€å‘ç¯å¢ƒè°ƒè¯•
```typescript
const DEBUG_STREAMING = process.env.NODE_ENV === 'development';

const debugLog = (...args: any[]) => {
  if (DEBUG_STREAMING) {
    console.log('[Streaming Debug]', ...args);
  }
};

// åœ¨æµå¼å¤„ç†ä¸­æ·»åŠ è°ƒè¯•ä¿¡æ¯
const handleStreamEvent = async (event: StreamEvent, messageId: string) => {
  debugLog('æ”¶åˆ°äº‹ä»¶:', event.type, event);
  
  switch (event.type) {
    case 'chunk':
      debugLog('å†…å®¹å—:', {
        length: event.content?.length,
        index: event.index,
        messageId
      });
      break;
  }
};
```

### ç”¨æˆ·ä½“éªŒä¼˜åŒ–
- **è‡ªç„¶çš„æ‰“å­—æ•ˆæœ** - é€‚å½“çš„å»¶è¿Ÿå’ŒåŠ¨ç”»
- **åœæ­¢ç”ŸæˆåŠŸèƒ½** - ç”¨æˆ·å¯ä»¥ä¸»åŠ¨åœæ­¢AIå›å¤
- **ç½‘ç»œçŠ¶æ€æç¤º** - æ˜¾ç¤ºè¿æ¥çŠ¶æ€
- **æ€§èƒ½ç›‘æ§** - å®æ—¶ç›‘æ§æµå¼å“åº”æ€§èƒ½

---

## ğŸ“‹ æ€»ç»“è¦ç‚¹

- **æµå¼æ•°æ®å¤„ç†** - ReadableStream APIçš„æ·±åº¦åº”ç”¨
- **å®æ—¶çŠ¶æ€æ›´æ–°** - é«˜æ•ˆçš„ReactçŠ¶æ€ç®¡ç†
- **æ‰“å­—æœºæ•ˆæœ** - è‡ªç„¶çš„æµå¼æ˜¾ç¤ºä½“éªŒ
- **æ€§èƒ½ä¼˜åŒ–** - æµå¼å“åº”çš„æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–
- **é”™è¯¯å¤„ç†** - å¥å£®çš„æµå¼é”™è¯¯æ¢å¤æœºåˆ¶

æµå¼å“åº”è®©AIå¯¹è¯æ›´åŠ ç”ŸåŠ¨ï¼

---

## ğŸš€ ç¬¬6ç« æ€»ç»“

æ­å–œå®Œæˆç¬¬6ç« æ ¸å¿ƒåŠŸèƒ½çš„å­¦ä¹ ï¼æ‚¨ç°åœ¨æ‹¥æœ‰äº†ï¼š

### âœ… å®Œæ•´çš„AIèŠå¤©åº”ç”¨
- **æ™ºèƒ½å¯¹è¯å¼•æ“** - LangGraphJS + OpenAI API
- **æµå¼å“åº”ä½“éªŒ** - å®æ—¶æ‰“å­—æœºæ•ˆæœ
- **ç°ä»£åŒ–ç•Œé¢** - å“åº”å¼èŠå¤©UI
- **çŠ¶æ€ç®¡ç†** - å®Œæ•´çš„ä¼šè¯å’Œæ¶ˆæ¯ç®¡ç†

### ğŸŒŸ ä¸‹ä¸€æ­¥æ–¹å‘
- **ç¬¬7ç« ï¼šç•Œé¢ä¼˜åŒ–** - è®©åº”ç”¨æ›´ç¾è§‚æ˜“ç”¨
- **ç¬¬8ç« ï¼šé«˜çº§ç‰¹æ€§** - å¤šä¼šè¯ç®¡ç†ç­‰åŠŸèƒ½

æ‚¨å·²ç»æŒæ¡äº†AIåº”ç”¨å¼€å‘çš„æ ¸å¿ƒæŠ€èƒ½ï¼
