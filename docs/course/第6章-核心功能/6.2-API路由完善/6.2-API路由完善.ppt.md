---
marp: true
theme: gaia
paginate: true
header: '6.2-API路由完善'
style: |
  section {
    font-size: 30px;
  }
---

<!-- _class: lead -->
# 第6章 核心功能 🔧

## 6.2 API路由完善

**构建生产级的聊天API接口**

---

## 🎯 学习目标

- **完善聊天API接口的流式响应实现**
- **优化历史记录获取和会话管理功能**
- **建立健壮的错误处理和验证机制**
- **实现生产级的API接口**

让AI引擎与前端无缝连接！

---

## 📚 API接口架构设计

### 核心接口规划
- **POST /api/chat** - 发送消息，支持流式响应
- **GET /api/chat** - 获取指定会话的历史记录
- **GET /api/chat/sessions** - 获取所有会话列表
- **POST /api/chat/sessions** - 创建新会话

### 数据流程
```
前端请求 → 参数验证 → LangGraph处理 → 流式响应 → 前端接收
```

---

## 💡 流式聊天API实现

```typescript
export async function POST(request: NextRequest) {
  try {
    const { message, threadId } = await request.json();
    
    // 详细的参数验证
    if (!message?.trim()) {
      return NextResponse.json({
        success: false,
        error: '消息内容不能为空',
        code: 'INVALID_MESSAGE'
      }, { status: 400 });
    }
    
    // 创建流式响应
    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder();
        
        // 使用LangGraphJS处理消息
        for await (const event of app.streamEvents(
          { messages: [new HumanMessage(message.trim())] },
          { version: 'v2', configurable: { thread_id: threadId } }
        )) {
          if (event.event === 'on_chat_model_stream') {
            const chunk = event.data?.chunk;
            if (chunk?.content) {
              controller.enqueue(encoder.encode(
                JSON.stringify({ type: 'chunk', content: chunk.content }) + '\n'
              ));
            }
          }
        }
        controller.close();
      }
    });

    return new Response(stream);
  } catch (error) {
    return NextResponse.json({ success: false, error: '服务器错误' });
  }
}
```

---

## 🔗 历史记录获取API

```typescript
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const threadId = searchParams.get('threadId');
    const limit = parseInt(searchParams.get('limit') || '50');
    
    // 参数验证
    if (!threadId) {
      return NextResponse.json({
        success: false,
        error: '缺少会话ID参数',
        code: 'MISSING_THREAD_ID'
      }, { status: 400 });
    }
    
    // 从LangGraph获取会话状态
    const state = await app.getState({
      configurable: { thread_id: threadId }
    });
    
    // 转换消息格式
    const messages = state.values.messages.map((msg: any, index: number) => {
      let role: 'user' | 'assistant' = 'assistant';
      
      if (msg.constructor?.name === 'HumanMessage') {
        role = 'user';
      }
      
      return {
        id: String(index + 1),
        content: msg.content || '',
        role,
        timestamp: new Date().toISOString(),
        sessionId: threadId
      };
    });
    
    return NextResponse.json({
      success: true,
      data: { threadId, history: messages.slice(-limit) }
    });

  } catch (error) {
    return NextResponse.json({
      success: false,
      error: '获取历史记录失败'
    }, { status: 500 });
  }
}
```

---

## 🔗 会话管理API

```typescript
// GET - 获取所有会话
export async function GET() {
  try {
    const sessions = getAllSessions();
    
    return NextResponse.json({
      success: true,
      data: { sessions, total: sessions.length }
    });
    
  } catch (error) {
    return NextResponse.json({
      success: false,
      error: '获取会话列表失败'
    }, { status: 500 });
  }
}

// POST - 创建新会话
export async function POST(request: NextRequest) {
  try {
    const { name } = await request.json();
    
    const sessionId = randomUUID();
    const sessionName = name?.trim() || `新会话-${sessionId.slice(0, 8)}`;
    
    createSession(sessionId, sessionName);
    
    return NextResponse.json({
      success: true,
      data: { id: sessionId, name: sessionName }
    });
    
  } catch (error) {
    return NextResponse.json({
      success: false,
      error: '创建会话失败'
    }, { status: 500 });
  }
}
```

---

## 🌟 流式响应优化

### 响应头配置
```typescript
return new Response(stream, {
  headers: {
    'Content-Type': 'text/plain; charset=utf-8',
    'Cache-Control': 'no-cache, no-store, must-revalidate',
    'Connection': 'keep-alive',
    'X-Accel-Buffering': 'no', // 禁用Nginx缓冲
  }
});
```

### 流式事件类型
- **start** - 流式响应开始
- **chunk** - 内容数据块
- **end** - 流式响应结束
- **error** - 错误信息

---

## 🔧 统一错误响应格式

```typescript
export interface APIError {
  success: false;
  error: string;
  code: string;
  timestamp?: string;
}

export function createErrorResponse(
  error: string, 
  code: string, 
  status: number = 500
): NextResponse {
  return NextResponse.json({
    success: false,
    error,
    code,
    timestamp: new Date().toISOString()
  }, { status });
}

// 常用错误响应
export const APIErrors = {
  INVALID_MESSAGE: () => createErrorResponse('消息内容无效', 'INVALID_MESSAGE', 400),
  MISSING_THREAD_ID: () => createErrorResponse('缺少会话ID', 'MISSING_THREAD_ID', 400),
  AI_SERVICE_ERROR: () => createErrorResponse('AI服务不可用', 'AI_SERVICE_ERROR', 503)
};
```

---

## 🔧 API性能监控

```typescript
export class APIMonitor {
  private static metrics: Map<string, number[]> = new Map();
  
  static recordResponseTime(endpoint: string, duration: number) {
    if (!this.metrics.has(endpoint)) {
      this.metrics.set(endpoint, []);
    }
    
    const times = this.metrics.get(endpoint)!;
    times.push(duration);
    
    // 只保留最近100次记录
    if (times.length > 100) {
      times.shift();
    }
  }
  
  static getAverageResponseTime(endpoint: string): number {
    const times = this.metrics.get(endpoint) || [];
    return times.reduce((sum, time) => sum + time, 0) / times.length;
  }
}
```

---

## 📋 总结要点

- **流式响应** - 实现实时的AI对话体验
- **历史记录** - 完整的会话状态管理
- **错误处理** - 健壮的API错误处理机制
- **参数验证** - 严格的输入验证和安全检查
- **性能监控** - API性能和错误监控

生产级的API设计让应用更可靠！

---

## 🚀 下一步预告

完成了API路由的完善后，我们将学习：

**6.3 前端聊天界面**
- 现代化聊天UI设计实现
- 响应式消息列表和输入组件
- 实时状态显示和交互反馈
- 完整的前端状态管理系统

构建用户喜爱的聊天界面！
