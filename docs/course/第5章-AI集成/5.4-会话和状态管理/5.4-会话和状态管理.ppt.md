---
marp: true
theme: gaia
paginate: true
header: '5.4-会话和状态管理'
style: |
  section {
    font-size: 30px;
  }
---

<!-- _class: lead -->
# 第5章 AI集成 🤖

## 5.4 会话和状态管理

**让AI记住每一次对话**

---

## 🎯 学习目标

- **理解LangGraphJS中的会话管理机制**
- **掌握Thread配置和状态持久化**
- **学会多轮对话的状态管理**
- **实现可靠的历史记录功能**

让AI拥有记忆，对话更智能！

---

## 📚 Thread会话管理

### Thread配置原理
```typescript
// 每个会话都有唯一的thread_id
const threadConfig = {
  configurable: { thread_id: 'user-123-session-456' }
};

// 在调用时传递配置
const response = await app.invoke(input, threadConfig);
```

独立的会话ID确保不同对话互不干扰！

---

## 🏗️ 检查点状态持久化

### 状态保存和恢复
```typescript
// 保存状态（自动完成）
await app.invoke(
  { messages: [new HumanMessage('你好')] },
  { configurable: { thread_id: sessionId } }
);

// 获取保存的状态
const savedState = await app.getState({
  configurable: { thread_id: sessionId }
});

console.log('历史消息:', savedState?.values?.messages || []);
```

SqliteSaver自动保存，随时恢复对话！

---

## 💡 会话管理工具类

```typescript
// app/utils/sessionManager.ts
export class SessionManager {
  // 生成新的会话ID
  static generateSessionId(): string {
    return `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  // 获取会话历史
  static async getSessionHistory(sessionId: string) {
    const state = await app.getState({
      configurable: { thread_id: sessionId }
    });
    return state?.values?.messages || [];
  }

  // 检查会话是否存在
  static async sessionExists(sessionId: string): Promise<boolean> {
    const state = await app.getState({
      configurable: { thread_id: sessionId }
    });
    return state?.values?.messages?.length > 0;
  }
}
```

---

## 🔗 API历史记录处理

```typescript
// app/api/chat/route.ts - GET方法
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const threadId = searchParams.get('threadId');

  try {
    const history = await SessionManager.getSessionHistory(threadId);
    
    // 转换为前端格式
    const messages = history.map((msg: any, index: number) => {
      let role: 'user' | 'assistant' = 'assistant';
      
      if (msg.constructor.name === 'HumanMessage') {
        role = 'user';
      }
      
      return {
        id: String(index + 1),
        content: msg.content || '',
        role,
        timestamp: new Date().toISOString(),
        sessionId: threadId
      };
    });

    return NextResponse.json({ success: true, data: { history: messages } });
  } catch (error) {
    return NextResponse.json({ success: false, error: '获取历史失败' });
  }
}
```

---

## 🔗 前端会话状态管理

```typescript
// 前端会话管理Hook
export function useSessionManager() {
  const [currentSessionId, setCurrentSessionId] = useState<string>('');
  const [sessionHistory, setSessionHistory] = useState<Message[]>([]);

  // 创建新会话
  const createNewSession = () => {
    const newSessionId = `session-${Date.now()}`;
    setCurrentSessionId(newSessionId);
    setSessionHistory([]);
    localStorage.setItem('currentSessionId', newSessionId);
    return newSessionId;
  };

  // 加载会话历史
  const loadSessionHistory = async (sessionId: string) => {
    const response = await fetch(`/api/chat?threadId=${sessionId}`);
    const data = await response.json();
    if (data.success) {
      setSessionHistory(data.data.history);
    }
  };

  return { currentSessionId, sessionHistory, createNewSession, loadSessionHistory };
}
```

---

## 🌟 多会话管理策略

### 会话生命周期
- **创建** - 用户开始新对话时自动创建
- **激活** - 用户切换到某个会话
- **保存** - 每次对话后自动保存状态
- **恢复** - 重新访问时恢复历史记录

### 会话存储策略
```typescript
// localStorage中保存当前会话
localStorage.setItem('currentSessionId', sessionId);

// 恢复时优先使用保存的会话ID
const savedSessionId = localStorage.getItem('currentSessionId');
if (savedSessionId) {
  setCurrentSessionId(savedSessionId);
  loadSessionHistory(savedSessionId);
}
```

---

## 🔧 调试和优化技巧

### 状态调试
```typescript
const debugSessionState = async (sessionId: string) => {
  const state = await app.getState({
    configurable: { thread_id: sessionId }
  });
  
  console.log('会话状态:', {
    sessionId,
    messageCount: state?.values?.messages?.length || 0,
    lastMessage: state?.values?.messages?.slice(-1)[0]?.content
  });
};
```

### 性能优化
- **懒加载** - 需要时才加载历史记录
- **分页处理** - 大量历史消息的分页显示
- **缓存策略** - 适当缓存最近的会话状态

---

## 📋 总结要点

- **Thread机制** - LangGraphJS的会话隔离机制
- **状态持久化** - SqliteSaver的自动状态保存
- **历史管理** - 多轮对话的完整历史记录
- **前后端同步** - 确保状态在前后端保持一致
- **用户体验** - 无缝的会话切换和历史恢复

完善的状态管理让AI应用更可靠！

---

## 🚀 下一步预告

掌握了会话和状态管理后，我们将学习：

**5.5 实际项目集成**
- 完整项目架构整合
- 前后端无缝连接
- 生产环境部署配置
- 完整AI聊天应用构建

让所有组件完美协作！

