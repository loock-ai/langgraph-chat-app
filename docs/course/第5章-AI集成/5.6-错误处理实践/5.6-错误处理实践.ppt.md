---
marp: true
theme: gaia
paginate: true
header: '5.6-错误处理实践'
style: |
  section {
    font-size: 30px;
  }
---

<!-- _class: lead -->
# 第5章 AI集成 🤖

## 5.6 错误处理实践

**构建可靠稳定的AI应用**

---

## 🎯 学习目标

- **建立健壮的AI应用错误处理机制**
- **掌握各种错误场景的处理策略**
- **实现用户友好的错误提示**
- **提升AI应用的可靠性和稳定性**

让AI应用在任何情况下都能优雅运行！

---

## 📚 AI应用错误类型

### 常见错误分类
```typescript
enum ErrorType {
  NETWORK_ERROR = 'network_error',           // 网络连接问题
  API_RATE_LIMIT = 'api_rate_limit',        // API调用限制
  MODEL_ERROR = 'model_error',              // AI模型错误
  VALIDATION_ERROR = 'validation_error',     // 输入验证错误
  STATE_ERROR = 'state_error',              // 状态管理错误
  UNKNOWN_ERROR = 'unknown_error'           // 未知错误
}
```

AI应用面临的错误比传统应用更复杂！

---

## 🏗️ 错误处理策略

### 错误处理原则
- **用户友好** - 错误信息要让用户能理解
- **可恢复性** - 尽可能提供恢复方案
- **日志记录** - 详细记录错误信息用于调试
- **优雅降级** - 在服务不可用时提供备选方案

### 错误类型判断
```typescript
// 错误类型映射
private static errorTypeMap = {
  'insufficient_quota': ErrorType.API_RATE_LIMIT,
  'rate_limit_exceeded': ErrorType.API_RATE_LIMIT,
  'model_overloaded': ErrorType.MODEL_ERROR,
  'invalid_request_error': ErrorType.VALIDATION_ERROR,
};
```

---

## 💡 统一错误处理类

```typescript
// app/utils/errorHandler.ts
export class AIErrorHandler {
  // 获取错误类型
  static getErrorType(error: any): ErrorType {
    if (error?.code && this.errorTypeMap[error.code]) {
      return this.errorTypeMap[error.code];
    }
    if (error?.message?.includes('network')) {
      return ErrorType.NETWORK_ERROR;
    }
    return ErrorType.UNKNOWN_ERROR;
  }

  // 获取用户友好的错误信息
  static getUserMessage(errorType: ErrorType): string {
    const messages = {
      [ErrorType.NETWORK_ERROR]: '网络连接不稳定，请检查网络后重试',
      [ErrorType.API_RATE_LIMIT]: 'AI服务使用频繁，请稍后再试',
      [ErrorType.MODEL_ERROR]: 'AI模型暂时不可用，请稍后重试'
    };
    return messages[errorType] || '服务暂时不可用，请稍后重试';
  }
}
```

---

## 🔗 API错误处理实现

```typescript
// app/api/chat/route.ts - 增强错误处理
export async function POST(request: NextRequest) {
  const maxRetries = 3;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      // API调用逻辑...
      return response;
      
    } catch (error) {
      const errorType = AIErrorHandler.getErrorType(error);
      
      // 判断是否可以重试
      if (AIErrorHandler.isRetryable(errorType) && attempt < maxRetries) {
        const delay = AIErrorHandler.getRetryDelay(errorType, attempt);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      
      // 返回用户友好的错误信息
      const userMessage = AIErrorHandler.getUserMessage(errorType);
      return NextResponse.json({
        success: false,
        error: userMessage,
        errorType
      }, { status: 500 });
    }
  }
}
```

---

## 🔗 重试机制实现

```typescript
// 判断是否可以重试
static isRetryable(errorType: ErrorType): boolean {
  return [
    ErrorType.NETWORK_ERROR,
    ErrorType.MODEL_ERROR,
    ErrorType.API_RATE_LIMIT
  ].includes(errorType);
}

// 获取重试延迟时间（指数退避）
static getRetryDelay(errorType: ErrorType, attempt: number): number {
  const baseDelays = {
    [ErrorType.NETWORK_ERROR]: 1000,    // 1秒
    [ErrorType.MODEL_ERROR]: 2000,     // 2秒
    [ErrorType.API_RATE_LIMIT]: 5000   // 5秒
  };
  
  const baseDelay = baseDelays[errorType] || 1000;
  return baseDelay * Math.pow(2, attempt - 1); // 指数退避
}
```

智能重试让应用更可靠！

---

## 🌟 前端错误处理

```typescript
// 前端错误处理Hook
export function useErrorHandler() {
  const [error, setError] = useState<string | null>(null);
  const [isRetrying, setIsRetrying] = useState(false);

  const handleStreamError = async (errorData: any, retryFunction: () => Promise<void>) => {
    setError(errorData.message);
    
    // 如果错误可重试，提供重试选项
    if (errorData.retryable && !isRetrying) {
      setIsRetrying(true);
      
      setTimeout(async () => {
        try {
          await retryFunction();
          setError(null);
        } catch (retryError) {
          setError('重试失败，请手动重新发送消息');
        } finally {
          setIsRetrying(false);
        }
      }, 5000);
    }
  };

  return { error, isRetrying, handleStreamError, clearError: () => setError(null) };
}
```

---

## 🔧 错误监控和日志

```typescript
// 错误监控系统
export class ErrorMonitor {
  static logError(error: any, context: string) {
    const errorInfo = {
      timestamp: new Date().toISOString(),
      context,
      message: error.message,
      stack: error.stack,
      type: AIErrorHandler.getErrorType(error)
    };
    
    console.error('错误日志:', errorInfo);
    
    // 生产环境发送到监控服务
    if (process.env.NODE_ENV === 'production') {
      // 发送到Sentry等监控服务
    }
  }
}

// 应用健康检查
export async function healthCheck() {
  try {
    await testAIConnection();
    await testDatabaseConnection();
    return { status: 'healthy' };
  } catch (error) {
    ErrorMonitor.logError(error, 'health-check');
    return { status: 'unhealthy', error: error.message };
  }
}
```

---

## 🔧 用户体验优化

### 错误UI设计
```typescript
// 错误提示组件
function ErrorMessage({ error, onRetry, isRetrying }: ErrorMessageProps) {
  return (
    <div className="bg-red-50 border border-red-200 rounded-lg p-4">
      <div className="flex items-center">
        <ExclamationTriangleIcon className="h-5 w-5 text-red-400" />
        <p className="ml-2 text-red-800">{error}</p>
      </div>
      
      {onRetry && (
        <button 
          onClick={onRetry}
          disabled={isRetrying}
          className="mt-2 px-4 py-2 bg-red-600 text-white rounded"
        >
          {isRetrying ? '重试中...' : '重试'}
        </button>
      )}
    </div>
  );
}
```

### 优雅降级策略
- **AI不可用时**：提供预设回复或建议
- **网络问题**：离线模式提示
- **流式中断**：显示已接收的内容

---

## 📋 总结要点

- **错误分类** - 不同类型的错误需要不同处理策略
- **用户体验** - 错误信息要友好，提供明确解决方案
- **自动恢复** - 实现重试机制和降级策略
- **监控日志** - 完善的错误监控有助于问题定位
- **健康检查** - 定期检查系统各组件状态

健壮的错误处理让AI应用更专业！

---

## 🚀 第5章总结

恭喜完成第5章AI集成的学习！您现在已经掌握了：

- ✅ **OpenAI API深度应用**
- ✅ **LangGraphJS状态图构建**
- ✅ **流式响应完整实现**
- ✅ **会话和状态管理**
- ✅ **项目完整集成**
- ✅ **健壮错误处理机制**

**下一步：第6章核心功能**
构建完整的聊天机器人应用！

