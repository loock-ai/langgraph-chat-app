---
marp: true
theme: gaia
paginate: true
header: '5.2-LangGraphJS核心应用'
style: |
  section {
    font-size: 30px;
  }
---

<!-- _class: lead -->
# 第5章 AI集成 🤖

## 5.2 LangGraphJS核心应用

**LangGraph状态图工作流构建**

---

## 🎯 学习目标

- **深入理解LangGraphJS的StateGraph概念**
- **掌握节点和边的设计原理**
- **学会实现检查点持久化**
- **构建可扩展的AI工作流**

打造智能化的AI工作流系统！

---

## 📚 StateGraph状态图基础

### 核心概念
```typescript
import { StateGraph, MessagesAnnotation, START, END } from '@langchain/langgraph';

// StateGraph - 有向图，定义AI应用的执行流程
// MessagesAnnotation - 定义状态的数据结构
// START和END - 流程的开始和结束节点
```

StateGraph让AI应用的逻辑更清晰、更可控！

---

## 🏗️ 节点(Node)设计原理

### 聊天节点实现
```typescript
// 聊天节点的核心函数
async function chatbotNode(state: typeof MessagesAnnotation.State) {
  // state.messages包含当前的对话历史
  const response = await model.invoke(state.messages);
  
  // 返回新的消息，LangGraph会自动合并到状态中
  return { messages: [response] };
}
```

每个节点专注一个任务，职责清晰！

---

## 💡 检查点持久化机制

### SqliteSaver配置
```typescript
import { SqliteSaver } from '@langchain/langgraph-checkpoint-sqlite';
import Database from 'better-sqlite3';

// 创建数据库连接
const db = new Database('chat_history.db');

// 创建检查点保存器
const checkpointer = new SqliteSaver(db);

// 编译应用时添加检查点支持
const app = workflow.compile({ checkpointer });
```

检查点让对话历史永不丢失！

---

## 🔗 完整聊天机器人实现

```typescript
// app/agent/chatbot.ts
import { StateGraph, MessagesAnnotation, START, END } from '@langchain/langgraph';

// 创建状态图工作流
const workflow = new StateGraph(MessagesAnnotation)
  .addNode('chatbot', chatbotNode)
  .addEdge(START, 'chatbot')
  .addEdge('chatbot', END);

// 创建检查点保存器
const checkpointer = new SqliteSaver(db);

// 编译应用
export const app = workflow.compile({ checkpointer });
```

---

## 🔗 状态管理和会话配置

```typescript
// 会话配置示例
const threadConfig = {
  configurable: { thread_id: 'user-session-123' }
};

// 调用聊天应用
const response = await app.invoke(
  { messages: [new HumanMessage('你好')] },
  threadConfig
);

// 获取会话状态
const state = await app.getState(threadConfig);
console.log('会话历史:', state?.values?.messages || []);
```

---

## 🌟 工作流设计原则

### 节点设计最佳实践
- **单一职责** - 每个节点只负责一个明确任务
- **状态一致性** - 确保状态在节点间正确传递
- **错误处理** - 在关键节点添加错误捕获
- **性能考虑** - 避免在节点中进行耗时操作

### 可扩展性设计
```typescript
// 扩展：添加工具调用节点
const workflow = new StateGraph(MessagesAnnotation)
  .addNode('chatbot', chatbotNode)
  .addNode('tool_call', toolCallNode)  // 新增工具节点
  .addConditionalEdges('chatbot', shouldUseTool, {
    'tool': 'tool_call',
    'end': END
  });
```

---

## 🔧 开发调试技巧

### 状态查看和调试
```typescript
// 调试工作流状态
async function debugWorkflow(threadId: string) {
  const state = await app.getState({
    configurable: { thread_id: threadId }
  });
  
  console.log('工作流状态:', {
    messageCount: state?.values?.messages?.length || 0,
    lastMessage: state?.values?.messages?.slice(-1)[0]?.content
  });
}
```

详细的调试信息让开发更高效！

---

## 📋 总结要点

- **StateGraph架构** - 提供灵活的AI工作流编排能力
- **节点设计** - 每个节点负责特定的处理任务
- **状态管理** - MessagesAnnotation定义标准消息状态
- **持久化机制** - SqliteSaver提供可靠的状态保存
- **可扩展性** - 支持复杂的条件分支和工具集成

LangGraphJS让AI应用架构更优雅！

---

## 🚀 下一步预告

掌握了LangGraphJS核心概念后，我们将学习：

**5.3 流式响应处理**
- streamEvents事件系统
- 实时AI对话体验
- 流式数据传输优化
- 前后端流式集成

让AI对话更加流畅自然！

