---
marp: true
theme: gaia
paginate: true
header: '7.3-交互功能实现'
style: |
  section {
    font-size: 30px;
  }
---

<!-- _class: lead -->
# 第7章 界面优化 🎨

## 7.3 交互功能实现

**让界面充满生命力的交互设计**

---

## 🎯 学习目标

- **实现丰富的键盘快捷键和手势操作**
- **掌握流畅的动画过渡和微交互设计**
- **建立完善的用户反馈和状态指示系统**
- **优化交互响应时间和用户体验**

让每一次交互都令人愉悦！

---

## 📚 现代交互设计原则

### 交互设计核心原则
- **即时反馈** - 每个操作都要有清晰的视觉反馈
- **渐进增强** - 基础功能先行，高级交互作为补充
- **一致性** - 相同类型的操作有相同的交互模式
- **可预测性** - 用户能够预期操作的结果

### 交互层次架构
```
基础交互层：核心操作 → 增强交互层：效率提升 → 高级交互层：体验优化
```

---

## 💡 键盘快捷键系统

```typescript
// 全局快捷键管理
export function useChatShortcuts({
  onNewSession, onToggleSidebar, onFocusInput
}) {
  const shortcuts = [
    {
      key: 'n', ctrlKey: true,
      callback: onNewSession,
      description: '新建会话'
    },
    {
      key: 'b', ctrlKey: true,
      callback: onToggleSidebar,
      description: '切换侧边栏'
    },
    {
      key: 'k', ctrlKey: true,
      callback: onFocusInput,
      description: '聚焦输入框'
    },
    {
      key: 'Escape',
      callback: () => document.activeElement?.blur(),
      description: '取消操作'
    }
  ];

  return useKeyboardShortcuts(shortcuts);
}
```

高效的键盘操作让专业用户爱不释手！

---

## 🔗 动画和过渡效果

### 消息进入动画
```typescript
import { motion, AnimatePresence } from 'framer-motion';

export function MessageAnimation({ message, children }) {
  const isUser = message.role === 'user';

  return (
    <motion.div
      initial={{
        opacity: 0,
        y: 20,
        x: isUser ? 20 : -20,
        scale: 0.95
      }}
      animate={{
        opacity: 1,
        y: 0,
        x: 0,
        scale: 1
      }}
      transition={{
        type: "spring",
        stiffness: 300,
        damping: 30,
        mass: 0.8
      }}
      layout
    >
      {children}
    </motion.div>
  );
}
```

---

## 🔗 流式文字动画

```typescript
// 打字机效果实现
export function TypewriterText({ text, speed = 50 }) {
  const [displayedText, setDisplayedText] = useState('');
  const [currentIndex, setCurrentIndex] = useState(0);

  useEffect(() => {
    if (currentIndex < text.length) {
      const timer = setTimeout(() => {
        setDisplayedText(text.slice(0, currentIndex + 1));
        setCurrentIndex(currentIndex + 1);
      }, speed);

      return () => clearTimeout(timer);
    }
  }, [currentIndex, text, speed]);

  return (
    <span>
      {displayedText}
      {currentIndex < text.length && (
        <motion.span
          animate={{ opacity: [1, 0] }}
          transition={{ repeat: Infinity, duration: 0.8 }}
          className="inline-block w-0.5 h-4 bg-current ml-1"
        />
      )}
    </span>
  );
}
```

自然的打字效果让AI回复更有温度！

---

## 🌟 微交互效果

### 按钮交互效果
```typescript
export function InteractiveButton({ children, onClick, variant = 'primary' }) {
  const [isPressed, setIsPressed] = useState(false);
  const [ripples, setRipples] = useState([]);

  const handleClick = (e) => {
    // 创建点击波纹效果
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const newRipple = { id: Date.now(), x, y };
    setRipples(prev => [...prev, newRipple]);

    // 清理波纹
    setTimeout(() => {
      setRipples(prev => prev.filter(ripple => ripple.id !== newRipple.id));
    }, 600);

    onClick?.();
  };

  return (
    <motion.button
      className="relative overflow-hidden rounded-lg font-medium transition-all duration-200"
      onClick={handleClick}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
    >
      {/* 波纹效果 */}
      {ripples.map(ripple => (
        <motion.div
          key={ripple.id}
          className="absolute bg-white/30 rounded-full pointer-events-none"
          style={{ left: ripple.x - 10, top: ripple.y - 10, width: 20, height: 20 }}
          initial={{ scale: 0, opacity: 1 }}
          animate={{ scale: 4, opacity: 0 }}
          transition={{ duration: 0.6 }}
        />
      ))}
      <span className="relative z-10">{children}</span>
    </motion.button>
  );
}
```

---

## 🔗 输入框焦点效果

```typescript
export function AnimatedInput({ value, onChange, label, error }) {
  const [isFocused, setIsFocused] = useState(false);
  const hasValue = value.length > 0;
  const shouldFloatLabel = isFocused || hasValue;

  return (
    <div className="relative">
      <motion.div
        className={cn(
          'relative border rounded-lg transition-all duration-200',
          isFocused ? 'border-blue-500 shadow-lg shadow-blue-500/20' : 'border-slate-300',
          error ? 'border-red-500' : ''
        )}
      >
        <input
          value={value}
          onChange={(e) => onChange(e.target.value)}
          onFocus={() => setIsFocused(true)}
          onBlur={() => setIsFocused(false)}
          className="w-full px-4 py-3 bg-transparent outline-none"
        />

        {/* 浮动标签 */}
        <motion.label
          className={cn(
            'absolute left-4 pointer-events-none transition-all duration-200',
            shouldFloatLabel ? 'top-2 text-xs' : 'top-1/2 -translate-y-1/2 text-sm',
            isFocused ? 'text-blue-500' : 'text-slate-500'
          )}
          animate={{
            scale: shouldFloatLabel ? 0.85 : 1,
          }}
        >
          {label}
        </motion.label>

        {/* 焦点指示线 */}
        <motion.div
          className="absolute bottom-0 left-0 h-0.5 bg-blue-500"
          initial={{ width: 0 }}
          animate={{ width: isFocused ? '100%' : 0 }}
        />
      </motion.div>
    </div>
  );
}
```

---

## 🔧 手势操作支持

```typescript
// 触摸手势处理
export function useGestures(handlers) {
  const elementRef = useRef(null);

  useEffect(() => {
    const element = elementRef.current;
    if (!element) return;

    const handleTouchStart = (e) => {
      const touch = e.touches[0];
      touchStartRef.current = {
        x: touch.clientX,
        y: touch.clientY,
        time: Date.now()
      };
    };

    const handleTouchEnd = (e) => {
      if (!touchStartRef.current) return;

      const touch = e.changedTouches[0];
      const deltaX = touch.clientX - touchStartRef.current.x;
      const deltaY = touch.clientY - touchStartRef.current.y;

      // 滑动检测
      const minSwipeDistance = 50;
      if (Math.abs(deltaX) > minSwipeDistance) {
        if (deltaX > 0) {
          handlers.onSwipeRight?.();
        } else {
          handlers.onSwipeLeft?.();
        }
      }
    };

    element.addEventListener('touchstart', handleTouchStart);
    element.addEventListener('touchend', handleTouchEnd);

    return () => {
      element.removeEventListener('touchstart', handleTouchStart);
      element.removeEventListener('touchend', handleTouchEnd);
    };
  }, [handlers]);

  return elementRef;
}
```

---

## 🔧 性能优化策略

### 动画性能配置
```typescript
export const animationConfig = {
  // 检测用户偏好
  reduceMotion: typeof window !== 'undefined' && 
    window.matchMedia('(prefers-reduced-motion: reduce)').matches,
  
  // 性能友好的动画配置
  spring: {
    type: "spring",
    stiffness: 300,
    damping: 30,
    mass: 0.8
  },
  
  // 快速动画
  fast: {
    duration: 0.2,
    ease: "easeOut"
  }
};

// 性能监控
export function usePerformanceMonitor() {
  useEffect(() => {
    let frameCount = 0;
    let lastTime = performance.now();
    
    function measureFPS() {
      frameCount++;
      const currentTime = performance.now();
      
      if (currentTime >= lastTime + 1000) {
        const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
        
        if (fps < 30) {
          console.warn('低帧率检测:', fps, 'FPS');
        }
        
        frameCount = 0;
        lastTime = currentTime;
      }
      
      requestAnimationFrame(measureFPS);
    }
    
    requestAnimationFrame(measureFPS);
  }, []);
}
```

---

## 📋 总结要点

- **键盘快捷键** - 高效的键盘操作系统
- **动画过渡** - 流畅自然的视觉效果
- **微交互** - 细致的用户反馈机制
- **手势操作** - 触摸设备的交互支持
- **性能优化** - 保证交互流畅性

丰富的交互让界面充满生命力！

---

## 🚀 下一步预告

完成了交互功能实现后，我们将学习：

**7.4 组件优化**
- React组件性能优化技巧
- 完善的可访问性支持
- 可复用的组件库构建
- 组件测试和质量保证

让组件更加专业和可维护！
