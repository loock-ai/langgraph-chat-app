---
marp: true
theme: gaia
paginate: true
header: '8.4-错误处理完善'
style: |
  section {
    font-size: 30px;
  }
---

<!-- _class: lead -->
# 8.4 错误处理完善 🛡️

## 建立健壮的错误处理和恢复机制

**第8章：高级特性**

---

## 🎯 学习目标

完成本节学习后，您将能够：

- **构建全面的错误处理体系**：覆盖前端、后端和AI集成的各种错误场景
- **实现用户友好的错误反馈**：提供清晰的错误信息和恢复建议
- **建立自动错误恢复机制**：实现重试逻辑、降级策略和容错处理
- **设计完善的错误监控系统**：记录、分析和预警各类错误
- **优化系统稳定性和可用性**：提升应用的健壮性和用户体验

---

## 🚨 错误分类体系

### 错误类型定义
```typescript
export enum ErrorType {
  // 网络错误
  NETWORK_ERROR = 'NETWORK_ERROR',
  TIMEOUT_ERROR = 'TIMEOUT_ERROR',
  
  // API错误
  API_ERROR = 'API_ERROR',
  AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR',
  RATE_LIMIT_ERROR = 'RATE_LIMIT_ERROR',
  
  // AI相关错误
  AI_MODEL_ERROR = 'AI_MODEL_ERROR',
  TOKEN_LIMIT_ERROR = 'TOKEN_LIMIT_ERROR',
  
  // 数据错误
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  DATABASE_ERROR = 'DATABASE_ERROR',
  
  // 系统错误
  SYSTEM_ERROR = 'SYSTEM_ERROR',
  UNKNOWN_ERROR = 'UNKNOWN_ERROR'
}

export enum ErrorSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}
```

### 应用错误基类
```typescript
export class AppError extends Error {
  constructor(
    public readonly type: ErrorType,
    message: string,
    public readonly userMessage: string,
    public readonly options: {
      severity?: ErrorSeverity;
      retryable?: boolean;
      context?: Record<string, any>;
    } = {}
  ) {
    super(message);
    this.name = 'AppError';
  }
}
```

---

## 🔄 智能重试机制

### 重试Hook实现
```typescript
export function useRetry(asyncFunction, options) {
  const { maxAttempts = 3, delay = 1000, exponentialBackoff = true } = options;
  const [state, setState] = useState({
    isRetrying: false,
    attempts: 0,
    lastError: null
  });

  const wrappedFunction = useCallback(async (...args) => {
    const executeWithRetry = async (attempt) => {
      try {
        setState(prev => ({ ...prev, attempts: attempt, isRetrying: attempt > 1 }));
        const result = await asyncFunction(...args);
        setState({ isRetrying: false, attempts: 0, lastError: null });
        return result;
      } catch (error) {
        setState(prev => ({ ...prev, lastError: error }));

        if (attempt < maxAttempts && shouldRetry(error)) {
          const retryDelay = exponentialBackoff 
            ? delay * Math.pow(2, attempt - 1)
            : delay;

          await new Promise(resolve => setTimeout(resolve, retryDelay));
          return executeWithRetry(attempt + 1);
        } else {
          setState(prev => ({ ...prev, isRetrying: false }));
          throw error;
        }
      }
    };

    return executeWithRetry(1);
  }, [asyncFunction, options]);

  return [wrappedFunction, state];
}
```

### 网络请求重试
```typescript
export function useApiWithRetry(url, options) {
  const apiCall = useCallback(async () => {
    const response = await fetch(url, options);
    
    if (!response.ok) {
      if (response.status >= 500 || response.status === 429) {
        throw new NetworkError(`API调用失败: ${response.status}`);
      } else if (response.status === 401) {
        throw new AppError(
          ErrorType.AUTHENTICATION_ERROR,
          'Authentication failed',
          '身份验证失败，请重新登录',
          { retryable: false }
        );
      }
    }
    
    return response.json();
  }, [url, options]);

  const [apiCallWithRetry, retryState] = useRetry(apiCall, {
    maxAttempts: 3,
    delay: 1000,
    exponentialBackoff: true
  });

  return { apiCall: apiCallWithRetry, ...retryState };
}
```

---

## ⚡ 断路器模式

### 断路器实现
```typescript
enum CircuitState {
  CLOSED = 'CLOSED',
  OPEN = 'OPEN',
  HALF_OPEN = 'HALF_OPEN'
}

class CircuitBreaker {
  private state = CircuitState.CLOSED;
  private failureCount = 0;
  private lastFailureTime = 0;

  constructor(private config = {
    failureThreshold: 5,
    recoveryTimeout: 30000,
    halfOpenMaxCalls: 3
  }) {}

  async execute(operation) {
    if (this.state === CircuitState.OPEN) {
      if (Date.now() - this.lastFailureTime > this.config.recoveryTimeout) {
        this.state = CircuitState.HALF_OPEN;
      } else {
        throw new AppError(
          ErrorType.SYSTEM_ERROR,
          'Circuit breaker is open',
          '服务暂时不可用，请稍后重试'
        );
      }
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess() {
    this.failureCount = 0;
    if (this.state === CircuitState.HALF_OPEN) {
      this.state = CircuitState.CLOSED;
    }
  }

  private onFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.failureCount >= this.config.failureThreshold) {
      this.state = CircuitState.OPEN;
    }
  }
}
```

---

## 🎯 用户友好的错误反馈

### 错误通知系统
```typescript
export const NotificationProvider = ({ children }) => {
  const [notifications, setNotifications] = useState([]);

  const showError = useCallback((error) => {
    if (error instanceof AppError) {
      return addNotification({
        type: 'error',
        title: '操作失败',
        message: error.userMessage,
        actions: error.options.retryable ? [
          {
            label: '重试',
            action: () => {
              // 触发重试逻辑
            }
          }
        ] : undefined,
        persistent: error.options.severity === ErrorSeverity.CRITICAL
      });
    }
  }, []);

  return (
    <NotificationContext.Provider value={{ showError, /* ... */ }}>
      {children}
      <NotificationContainer notifications={notifications} />
    </NotificationContext.Provider>
  );
};
```

### 错误通知组件
```typescript
const NotificationItem = ({ notification, onClose }) => {
  const getTypeStyles = (type) => {
    switch (type) {
      case 'error':
        return 'bg-red-50 border-red-200 text-red-800';
      case 'warning':
        return 'bg-yellow-50 border-yellow-200 text-yellow-800';
      case 'success':
        return 'bg-green-50 border-green-200 text-green-800';
      default:
        return 'bg-gray-50 border-gray-200 text-gray-800';
    }
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: -20, x: 20 }}
      animate={{ opacity: 1, y: 0, x: 0 }}
      exit={{ opacity: 0, y: -20, x: 20 }}
      className={`max-w-sm w-full bg-white shadow-lg rounded-lg 
                  border ${getTypeStyles(notification.type)}`}
    >
      <div className="p-4">
        <div className="flex items-start">
          <div className="ml-3 w-0 flex-1">
            <p className="text-sm font-medium">{notification.title}</p>
            <p className="mt-1 text-sm opacity-90">{notification.message}</p>
            
            {notification.actions && (
              <div className="mt-3 flex space-x-2">
                {notification.actions.map((action, index) => (
                  <button
                    key={index}
                    onClick={action.action}
                    className="text-xs px-3 py-1 rounded-md font-medium 
                               bg-blue-600 text-white hover:bg-blue-700"
                  >
                    {action.label}
                  </button>
                ))}
              </div>
            )}
          </div>
          <button onClick={onClose} className="ml-4 flex-shrink-0">
            <XIcon className="w-4 h-4" />
          </button>
        </div>
      </div>
    </motion.div>
  );
};
```

---

## 🛡️ 错误边界组件

### React错误边界
```typescript
export class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    this.setState({ errorInfo });

    // 记录错误
    const structuredError = new AppError(
      ErrorType.SYSTEM_ERROR,
      `React Error Boundary: ${error.message}`,
      '应用出现异常，正在尝试恢复',
      {
        severity: ErrorSeverity.HIGH,
        context: { componentStack: errorInfo.componentStack }
      }
    );

    this.logError(structuredError, errorInfo);
    
    // 自动恢复尝试
    this.scheduleAutoRecovery();
  }

  private scheduleAutoRecovery() {
    setTimeout(() => {
      this.setState({
        hasError: false,
        error: null,
        errorInfo: null
      });
    }, 10000);
  }

  render() {
    if (this.state.hasError) {
      return (
        <DefaultErrorFallback
          error={this.state.error}
          onRetry={() => this.setState({ hasError: false })}
        />
      );
    }

    return this.props.children;
  }
}
```

### 错误回退界面
```typescript
const DefaultErrorFallback = ({ error, onRetry }) => (
  <div className="min-h-screen flex items-center justify-center bg-gray-50">
    <div className="max-w-md w-full space-y-8 text-center">
      <div className="mx-auto h-24 w-24 text-red-500 mb-4">
        <ExclamationTriangleIcon />
      </div>
      
      <h2 className="text-3xl font-extrabold text-gray-900">
        应用出现异常
      </h2>
      
      <p className="text-gray-600">
        应用遇到了意外错误，我们正在尝试恢复
      </p>

      <div className="space-y-4">
        <button
          onClick={onRetry}
          className="w-full bg-blue-600 text-white py-2 px-4 rounded-md 
                     hover:bg-blue-700 transition-colors"
        >
          重新加载
        </button>

        <button
          onClick={() => window.location.reload()}
          className="w-full bg-gray-200 text-gray-700 py-2 px-4 rounded-md 
                     hover:bg-gray-300 transition-colors"
        >
          刷新页面
        </button>
      </div>
    </div>
  </div>
);
```

---

## 📊 错误监控系统

### 错误监控Hook
```typescript
export function useErrorMonitoring(config) {
  const statsRef = useRef({
    totalErrors: 0,
    errorsByType: {},
    recentErrors: [],
    errorRate: 0
  });

  const recordError = useCallback((error) => {
    const stats = statsRef.current;
    const now = Date.now();

    // 更新统计信息
    stats.totalErrors++;
    stats.errorsByType[error.type] = (stats.errorsByType[error.type] || 0) + 1;
    
    // 添加到最近错误列表
    stats.recentErrors.unshift(error);
    if (stats.recentErrors.length > config.maxRecentErrors) {
      stats.recentErrors = stats.recentErrors.slice(0, config.maxRecentErrors);
    }

    console.group(`📊 Error Monitoring - ${error.type}`);
    console.log('Error:', error);
    console.log('Stats:', stats);
    console.groupEnd();
  }, [config.maxRecentErrors]);

  const sendMonitoringReport = useCallback(() => {
    const stats = statsRef.current;
    
    if (stats.totalErrors > 0) {
      const report = {
        timestamp: new Date().toISOString(),
        ...stats,
        userAgent: navigator.userAgent,
        url: window.location.href
      };

      fetch('/api/monitoring/errors', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(report)
      }).catch(err => {
        console.warn('Failed to send monitoring report:', err);
      });
    }
  }, []);

  return { recordError, getStats: () => statsRef.current, sendReport: sendMonitoringReport };
}
```

---

## 🌐 API客户端错误处理

### 统一API客户端
```typescript
class APIClient {
  private config = {
    baseURL: '',
    timeout: 10000,
    retries: 3,
    retryDelay: 1000
  };

  private handleHTTPError(response) {
    const { status, statusText } = response;

    switch (status) {
      case 400:
        throw new AppError(
          ErrorType.VALIDATION_ERROR,
          `Bad Request: ${statusText}`,
          '请求参数有误，请检查输入',
          { retryable: false }
        );
      
      case 401:
        throw new AppError(
          ErrorType.AUTHENTICATION_ERROR,
          `Unauthorized: ${statusText}`,
          '身份验证失败，请重新登录',
          { retryable: false }
        );
      
      case 429:
        throw new AppError(
          ErrorType.RATE_LIMIT_ERROR,
          `Too Many Requests: ${statusText}`,
          '请求过于频繁，请稍后重试',
          { retryable: true }
        );
      
      case 500:
      case 502:
      case 503:
      case 504:
        throw new AppError(
          ErrorType.API_ERROR,
          `Server Error: ${status} ${statusText}`,
          '服务器暂时不可用，请稍后重试',
          { retryable: true }
        );
      
      default:
        throw new AppError(
          ErrorType.API_ERROR,
          `HTTP Error: ${status} ${statusText}`,
          '网络请求失败，请稍后重试',
          { retryable: status >= 500 }
        );
    }
  }

  async executeRequest(url, options, attempt = 1) {
    try {
      const controller = new AbortController();
      setTimeout(() => controller.abort(), this.config.timeout);

      const response = await fetch(`${this.config.baseURL}${url}`, {
        ...options,
        signal: controller.signal
      });

      if (!response.ok) {
        this.handleHTTPError(response);
      }

      return await response.json();
    } catch (error) {
      if (error instanceof DOMException && error.name === 'AbortError') {
        throw new AppError(
          ErrorType.TIMEOUT_ERROR,
          'Request timeout',
          '请求超时，请检查网络连接'
        );
      }

      // 重试逻辑
      if (error instanceof AppError && error.options.retryable && attempt < this.config.retries) {
        const delay = this.config.retryDelay * Math.pow(2, attempt - 1);
        await new Promise(resolve => setTimeout(resolve, delay));
        return this.executeRequest(url, options, attempt + 1);
      }

      throw error;
    }
  }
}
```

---

## 🧪 错误处理测试

### 错误边界测试
```typescript
describe('ErrorBoundary', () => {
  test('captures and displays errors', () => {
    const ThrowError = ({ shouldThrow }) => {
      if (shouldThrow) throw new Error('Test error');
      return <div>No error</div>;
    };

    const mockOnError = jest.fn();
    
    render(
      <ErrorBoundary onError={mockOnError}>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    );

    expect(screen.getByText('应用出现异常')).toBeInTheDocument();
    expect(mockOnError).toHaveBeenCalled();
  });

  test('allows retry functionality', async () => {
    const { rerender } = render(
      <ErrorBoundary>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    );

    const retryButton = screen.getByText('重新加载');
    
    rerender(
      <ErrorBoundary>
        <ThrowError shouldThrow={false} />
      </ErrorBoundary>
    );

    fireEvent.click(retryButton);

    await waitFor(() => {
      expect(screen.getByText('No error')).toBeInTheDocument();
    });
  });
});
```

### API错误处理测试
```typescript
describe('APIClient Error Handling', () => {
  test('handles network errors', async () => {
    global.fetch = jest.fn().mockRejectedValue(new TypeError('Network error'));

    const { apiCall } = useApiWithRetry('/test/endpoint');

    await expect(apiCall()).rejects.toThrow(NetworkError);
  });

  test('retries failed requests', async () => {
    global.fetch = jest.fn()
      .mockRejectedValueOnce(new TypeError('Network error'))
      .mockRejectedValueOnce(new TypeError('Network error'))
      .mockResolvedValue({
        ok: true,
        json: async () => ({ success: true })
      });

    const { apiCall } = useApiWithRetry('/test/endpoint');

    const result = await apiCall();
    expect(result).toEqual({ success: true });
    expect(fetch).toHaveBeenCalledTimes(3);
  });
});
```

---

## 📈 监控和分析

### 错误统计分析
```typescript
export function useErrorAnalytics() {
  const [analytics, setAnalytics] = useState({
    errorTrends: [],
    topErrors: [],
    errorDistribution: {},
    recoveryRate: 0
  });

  const analyzeErrors = useCallback((errors) => {
    // 错误趋势分析
    const trends = errors.reduce((acc, error) => {
      const hour = new Date(error.timestamp).getHours();
      acc[hour] = (acc[hour] || 0) + 1;
      return acc;
    }, {});

    // 错误类型分布
    const distribution = errors.reduce((acc, error) => {
      acc[error.type] = (acc[error.type] || 0) + 1;
      return acc;
    }, {});

    // 恢复率计算
    const retriedErrors = errors.filter(e => e.retryAttempts > 0);
    const recoveredErrors = retriedErrors.filter(e => e.recovered);
    const recoveryRate = retriedErrors.length > 0 
      ? (recoveredErrors.length / retriedErrors.length) * 100 
      : 0;

    setAnalytics({
      errorTrends: Object.entries(trends),
      topErrors: Object.entries(distribution)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 5),
      errorDistribution: distribution,
      recoveryRate
    });
  }, []);

  return { analytics, analyzeErrors };
}
```

---

## 💡 最佳实践总结

### 错误处理原则
- **分层处理**：网络层、业务层、UI层分别处理对应错误
- **用户友好**：错误信息要清晰易懂，提供解决建议
- **自动恢复**：可恢复的错误自动重试，减少用户干预
- **监控报警**：重要错误及时记录和报警

### 性能考虑
- **错误边界粒度**：合理设置错误边界范围
- **重试策略**：指数退避避免系统过载
- **断路器保护**：防止级联故障
- **内存管理**：错误日志定期清理

### 安全性设计
- **敏感信息保护**：错误信息不暴露系统内部细节
- **日志脱敏**：记录错误时过滤敏感数据
- **访问控制**：错误监控接口需要权限验证

---

## 📋 学习检查点

### 错误处理体系完成度
- ✅ **错误分类系统**：完整的错误类型和严重级别定义
- ✅ **重试机制**：智能重试和断路器模式实现
- ✅ **用户反馈**：友好的错误通知和恢复建议
- ✅ **错误边界**：React组件错误捕获和恢复
- ✅ **监控分析**：错误统计、趋势分析和报警

### 系统健壮性提升
- **容错能力**：各类异常场景的优雅处理
- **用户体验**：错误状态下的良好交互体验
- **系统稳定性**：自动恢复和降级保护机制
- **可观测性**：完善的错误监控和分析能力

**恭喜完成8.4节学习！您已具备构建企业级健壮系统的错误处理能力！** 🎉
