---
marp: true
theme: gaia
paginate: true
header: '8.4-é”™è¯¯å¤„ç†å®Œå–„'
style: |
  section {
    font-size: 30px;
  }
---

<!-- _class: lead -->
# 8.4 é”™è¯¯å¤„ç†å®Œå–„ ğŸ›¡ï¸

## å»ºç«‹å¥å£®çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶

**ç¬¬8ç« ï¼šé«˜çº§ç‰¹æ€§**

---

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬èŠ‚å­¦ä¹ åï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š

- **æ„å»ºå…¨é¢çš„é”™è¯¯å¤„ç†ä½“ç³»**ï¼šè¦†ç›–å‰ç«¯ã€åç«¯å’ŒAIé›†æˆçš„å„ç§é”™è¯¯åœºæ™¯
- **å®ç°ç”¨æˆ·å‹å¥½çš„é”™è¯¯åé¦ˆ**ï¼šæä¾›æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯å’Œæ¢å¤å»ºè®®
- **å»ºç«‹è‡ªåŠ¨é”™è¯¯æ¢å¤æœºåˆ¶**ï¼šå®ç°é‡è¯•é€»è¾‘ã€é™çº§ç­–ç•¥å’Œå®¹é”™å¤„ç†
- **è®¾è®¡å®Œå–„çš„é”™è¯¯ç›‘æ§ç³»ç»Ÿ**ï¼šè®°å½•ã€åˆ†æå’Œé¢„è­¦å„ç±»é”™è¯¯
- **ä¼˜åŒ–ç³»ç»Ÿç¨³å®šæ€§å’Œå¯ç”¨æ€§**ï¼šæå‡åº”ç”¨çš„å¥å£®æ€§å’Œç”¨æˆ·ä½“éªŒ

---

## ğŸš¨ é”™è¯¯åˆ†ç±»ä½“ç³»

### é”™è¯¯ç±»å‹å®šä¹‰
```typescript
export enum ErrorType {
  // ç½‘ç»œé”™è¯¯
  NETWORK_ERROR = 'NETWORK_ERROR',
  TIMEOUT_ERROR = 'TIMEOUT_ERROR',
  
  // APIé”™è¯¯
  API_ERROR = 'API_ERROR',
  AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR',
  RATE_LIMIT_ERROR = 'RATE_LIMIT_ERROR',
  
  // AIç›¸å…³é”™è¯¯
  AI_MODEL_ERROR = 'AI_MODEL_ERROR',
  TOKEN_LIMIT_ERROR = 'TOKEN_LIMIT_ERROR',
  
  // æ•°æ®é”™è¯¯
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  DATABASE_ERROR = 'DATABASE_ERROR',
  
  // ç³»ç»Ÿé”™è¯¯
  SYSTEM_ERROR = 'SYSTEM_ERROR',
  UNKNOWN_ERROR = 'UNKNOWN_ERROR'
}

export enum ErrorSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}
```

### åº”ç”¨é”™è¯¯åŸºç±»
```typescript
export class AppError extends Error {
  constructor(
    public readonly type: ErrorType,
    message: string,
    public readonly userMessage: string,
    public readonly options: {
      severity?: ErrorSeverity;
      retryable?: boolean;
      context?: Record<string, any>;
    } = {}
  ) {
    super(message);
    this.name = 'AppError';
  }
}
```

---

## ğŸ”„ æ™ºèƒ½é‡è¯•æœºåˆ¶

### é‡è¯•Hookå®ç°
```typescript
export function useRetry(asyncFunction, options) {
  const { maxAttempts = 3, delay = 1000, exponentialBackoff = true } = options;
  const [state, setState] = useState({
    isRetrying: false,
    attempts: 0,
    lastError: null
  });

  const wrappedFunction = useCallback(async (...args) => {
    const executeWithRetry = async (attempt) => {
      try {
        setState(prev => ({ ...prev, attempts: attempt, isRetrying: attempt > 1 }));
        const result = await asyncFunction(...args);
        setState({ isRetrying: false, attempts: 0, lastError: null });
        return result;
      } catch (error) {
        setState(prev => ({ ...prev, lastError: error }));

        if (attempt < maxAttempts && shouldRetry(error)) {
          const retryDelay = exponentialBackoff 
            ? delay * Math.pow(2, attempt - 1)
            : delay;

          await new Promise(resolve => setTimeout(resolve, retryDelay));
          return executeWithRetry(attempt + 1);
        } else {
          setState(prev => ({ ...prev, isRetrying: false }));
          throw error;
        }
      }
    };

    return executeWithRetry(1);
  }, [asyncFunction, options]);

  return [wrappedFunction, state];
}
```

### ç½‘ç»œè¯·æ±‚é‡è¯•
```typescript
export function useApiWithRetry(url, options) {
  const apiCall = useCallback(async () => {
    const response = await fetch(url, options);
    
    if (!response.ok) {
      if (response.status >= 500 || response.status === 429) {
        throw new NetworkError(`APIè°ƒç”¨å¤±è´¥: ${response.status}`);
      } else if (response.status === 401) {
        throw new AppError(
          ErrorType.AUTHENTICATION_ERROR,
          'Authentication failed',
          'èº«ä»½éªŒè¯å¤±è´¥ï¼Œè¯·é‡æ–°ç™»å½•',
          { retryable: false }
        );
      }
    }
    
    return response.json();
  }, [url, options]);

  const [apiCallWithRetry, retryState] = useRetry(apiCall, {
    maxAttempts: 3,
    delay: 1000,
    exponentialBackoff: true
  });

  return { apiCall: apiCallWithRetry, ...retryState };
}
```

---

## âš¡ æ–­è·¯å™¨æ¨¡å¼

### æ–­è·¯å™¨å®ç°
```typescript
enum CircuitState {
  CLOSED = 'CLOSED',
  OPEN = 'OPEN',
  HALF_OPEN = 'HALF_OPEN'
}

class CircuitBreaker {
  private state = CircuitState.CLOSED;
  private failureCount = 0;
  private lastFailureTime = 0;

  constructor(private config = {
    failureThreshold: 5,
    recoveryTimeout: 30000,
    halfOpenMaxCalls: 3
  }) {}

  async execute(operation) {
    if (this.state === CircuitState.OPEN) {
      if (Date.now() - this.lastFailureTime > this.config.recoveryTimeout) {
        this.state = CircuitState.HALF_OPEN;
      } else {
        throw new AppError(
          ErrorType.SYSTEM_ERROR,
          'Circuit breaker is open',
          'æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åé‡è¯•'
        );
      }
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  private onSuccess() {
    this.failureCount = 0;
    if (this.state === CircuitState.HALF_OPEN) {
      this.state = CircuitState.CLOSED;
    }
  }

  private onFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.failureCount >= this.config.failureThreshold) {
      this.state = CircuitState.OPEN;
    }
  }
}
```

---

## ğŸ¯ ç”¨æˆ·å‹å¥½çš„é”™è¯¯åé¦ˆ

### é”™è¯¯é€šçŸ¥ç³»ç»Ÿ
```typescript
export const NotificationProvider = ({ children }) => {
  const [notifications, setNotifications] = useState([]);

  const showError = useCallback((error) => {
    if (error instanceof AppError) {
      return addNotification({
        type: 'error',
        title: 'æ“ä½œå¤±è´¥',
        message: error.userMessage,
        actions: error.options.retryable ? [
          {
            label: 'é‡è¯•',
            action: () => {
              // è§¦å‘é‡è¯•é€»è¾‘
            }
          }
        ] : undefined,
        persistent: error.options.severity === ErrorSeverity.CRITICAL
      });
    }
  }, []);

  return (
    <NotificationContext.Provider value={{ showError, /* ... */ }}>
      {children}
      <NotificationContainer notifications={notifications} />
    </NotificationContext.Provider>
  );
};
```

### é”™è¯¯é€šçŸ¥ç»„ä»¶
```typescript
const NotificationItem = ({ notification, onClose }) => {
  const getTypeStyles = (type) => {
    switch (type) {
      case 'error':
        return 'bg-red-50 border-red-200 text-red-800';
      case 'warning':
        return 'bg-yellow-50 border-yellow-200 text-yellow-800';
      case 'success':
        return 'bg-green-50 border-green-200 text-green-800';
      default:
        return 'bg-gray-50 border-gray-200 text-gray-800';
    }
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: -20, x: 20 }}
      animate={{ opacity: 1, y: 0, x: 0 }}
      exit={{ opacity: 0, y: -20, x: 20 }}
      className={`max-w-sm w-full bg-white shadow-lg rounded-lg 
                  border ${getTypeStyles(notification.type)}`}
    >
      <div className="p-4">
        <div className="flex items-start">
          <div className="ml-3 w-0 flex-1">
            <p className="text-sm font-medium">{notification.title}</p>
            <p className="mt-1 text-sm opacity-90">{notification.message}</p>
            
            {notification.actions && (
              <div className="mt-3 flex space-x-2">
                {notification.actions.map((action, index) => (
                  <button
                    key={index}
                    onClick={action.action}
                    className="text-xs px-3 py-1 rounded-md font-medium 
                               bg-blue-600 text-white hover:bg-blue-700"
                  >
                    {action.label}
                  </button>
                ))}
              </div>
            )}
          </div>
          <button onClick={onClose} className="ml-4 flex-shrink-0">
            <XIcon className="w-4 h-4" />
          </button>
        </div>
      </div>
    </motion.div>
  );
};
```

---

## ğŸ›¡ï¸ é”™è¯¯è¾¹ç•Œç»„ä»¶

### Reacté”™è¯¯è¾¹ç•Œ
```typescript
export class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    this.setState({ errorInfo });

    // è®°å½•é”™è¯¯
    const structuredError = new AppError(
      ErrorType.SYSTEM_ERROR,
      `React Error Boundary: ${error.message}`,
      'åº”ç”¨å‡ºç°å¼‚å¸¸ï¼Œæ­£åœ¨å°è¯•æ¢å¤',
      {
        severity: ErrorSeverity.HIGH,
        context: { componentStack: errorInfo.componentStack }
      }
    );

    this.logError(structuredError, errorInfo);
    
    // è‡ªåŠ¨æ¢å¤å°è¯•
    this.scheduleAutoRecovery();
  }

  private scheduleAutoRecovery() {
    setTimeout(() => {
      this.setState({
        hasError: false,
        error: null,
        errorInfo: null
      });
    }, 10000);
  }

  render() {
    if (this.state.hasError) {
      return (
        <DefaultErrorFallback
          error={this.state.error}
          onRetry={() => this.setState({ hasError: false })}
        />
      );
    }

    return this.props.children;
  }
}
```

### é”™è¯¯å›é€€ç•Œé¢
```typescript
const DefaultErrorFallback = ({ error, onRetry }) => (
  <div className="min-h-screen flex items-center justify-center bg-gray-50">
    <div className="max-w-md w-full space-y-8 text-center">
      <div className="mx-auto h-24 w-24 text-red-500 mb-4">
        <ExclamationTriangleIcon />
      </div>
      
      <h2 className="text-3xl font-extrabold text-gray-900">
        åº”ç”¨å‡ºç°å¼‚å¸¸
      </h2>
      
      <p className="text-gray-600">
        åº”ç”¨é‡åˆ°äº†æ„å¤–é”™è¯¯ï¼Œæˆ‘ä»¬æ­£åœ¨å°è¯•æ¢å¤
      </p>

      <div className="space-y-4">
        <button
          onClick={onRetry}
          className="w-full bg-blue-600 text-white py-2 px-4 rounded-md 
                     hover:bg-blue-700 transition-colors"
        >
          é‡æ–°åŠ è½½
        </button>

        <button
          onClick={() => window.location.reload()}
          className="w-full bg-gray-200 text-gray-700 py-2 px-4 rounded-md 
                     hover:bg-gray-300 transition-colors"
        >
          åˆ·æ–°é¡µé¢
        </button>
      </div>
    </div>
  </div>
);
```

---

## ğŸ“Š é”™è¯¯ç›‘æ§ç³»ç»Ÿ

### é”™è¯¯ç›‘æ§Hook
```typescript
export function useErrorMonitoring(config) {
  const statsRef = useRef({
    totalErrors: 0,
    errorsByType: {},
    recentErrors: [],
    errorRate: 0
  });

  const recordError = useCallback((error) => {
    const stats = statsRef.current;
    const now = Date.now();

    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    stats.totalErrors++;
    stats.errorsByType[error.type] = (stats.errorsByType[error.type] || 0) + 1;
    
    // æ·»åŠ åˆ°æœ€è¿‘é”™è¯¯åˆ—è¡¨
    stats.recentErrors.unshift(error);
    if (stats.recentErrors.length > config.maxRecentErrors) {
      stats.recentErrors = stats.recentErrors.slice(0, config.maxRecentErrors);
    }

    console.group(`ğŸ“Š Error Monitoring - ${error.type}`);
    console.log('Error:', error);
    console.log('Stats:', stats);
    console.groupEnd();
  }, [config.maxRecentErrors]);

  const sendMonitoringReport = useCallback(() => {
    const stats = statsRef.current;
    
    if (stats.totalErrors > 0) {
      const report = {
        timestamp: new Date().toISOString(),
        ...stats,
        userAgent: navigator.userAgent,
        url: window.location.href
      };

      fetch('/api/monitoring/errors', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(report)
      }).catch(err => {
        console.warn('Failed to send monitoring report:', err);
      });
    }
  }, []);

  return { recordError, getStats: () => statsRef.current, sendReport: sendMonitoringReport };
}
```

---

## ğŸŒ APIå®¢æˆ·ç«¯é”™è¯¯å¤„ç†

### ç»Ÿä¸€APIå®¢æˆ·ç«¯
```typescript
class APIClient {
  private config = {
    baseURL: '',
    timeout: 10000,
    retries: 3,
    retryDelay: 1000
  };

  private handleHTTPError(response) {
    const { status, statusText } = response;

    switch (status) {
      case 400:
        throw new AppError(
          ErrorType.VALIDATION_ERROR,
          `Bad Request: ${statusText}`,
          'è¯·æ±‚å‚æ•°æœ‰è¯¯ï¼Œè¯·æ£€æŸ¥è¾“å…¥',
          { retryable: false }
        );
      
      case 401:
        throw new AppError(
          ErrorType.AUTHENTICATION_ERROR,
          `Unauthorized: ${statusText}`,
          'èº«ä»½éªŒè¯å¤±è´¥ï¼Œè¯·é‡æ–°ç™»å½•',
          { retryable: false }
        );
      
      case 429:
        throw new AppError(
          ErrorType.RATE_LIMIT_ERROR,
          `Too Many Requests: ${statusText}`,
          'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åé‡è¯•',
          { retryable: true }
        );
      
      case 500:
      case 502:
      case 503:
      case 504:
        throw new AppError(
          ErrorType.API_ERROR,
          `Server Error: ${status} ${statusText}`,
          'æœåŠ¡å™¨æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åé‡è¯•',
          { retryable: true }
        );
      
      default:
        throw new AppError(
          ErrorType.API_ERROR,
          `HTTP Error: ${status} ${statusText}`,
          'ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•',
          { retryable: status >= 500 }
        );
    }
  }

  async executeRequest(url, options, attempt = 1) {
    try {
      const controller = new AbortController();
      setTimeout(() => controller.abort(), this.config.timeout);

      const response = await fetch(`${this.config.baseURL}${url}`, {
        ...options,
        signal: controller.signal
      });

      if (!response.ok) {
        this.handleHTTPError(response);
      }

      return await response.json();
    } catch (error) {
      if (error instanceof DOMException && error.name === 'AbortError') {
        throw new AppError(
          ErrorType.TIMEOUT_ERROR,
          'Request timeout',
          'è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥'
        );
      }

      // é‡è¯•é€»è¾‘
      if (error instanceof AppError && error.options.retryable && attempt < this.config.retries) {
        const delay = this.config.retryDelay * Math.pow(2, attempt - 1);
        await new Promise(resolve => setTimeout(resolve, delay));
        return this.executeRequest(url, options, attempt + 1);
      }

      throw error;
    }
  }
}
```

---

## ğŸ§ª é”™è¯¯å¤„ç†æµ‹è¯•

### é”™è¯¯è¾¹ç•Œæµ‹è¯•
```typescript
describe('ErrorBoundary', () => {
  test('captures and displays errors', () => {
    const ThrowError = ({ shouldThrow }) => {
      if (shouldThrow) throw new Error('Test error');
      return <div>No error</div>;
    };

    const mockOnError = jest.fn();
    
    render(
      <ErrorBoundary onError={mockOnError}>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    );

    expect(screen.getByText('åº”ç”¨å‡ºç°å¼‚å¸¸')).toBeInTheDocument();
    expect(mockOnError).toHaveBeenCalled();
  });

  test('allows retry functionality', async () => {
    const { rerender } = render(
      <ErrorBoundary>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    );

    const retryButton = screen.getByText('é‡æ–°åŠ è½½');
    
    rerender(
      <ErrorBoundary>
        <ThrowError shouldThrow={false} />
      </ErrorBoundary>
    );

    fireEvent.click(retryButton);

    await waitFor(() => {
      expect(screen.getByText('No error')).toBeInTheDocument();
    });
  });
});
```

### APIé”™è¯¯å¤„ç†æµ‹è¯•
```typescript
describe('APIClient Error Handling', () => {
  test('handles network errors', async () => {
    global.fetch = jest.fn().mockRejectedValue(new TypeError('Network error'));

    const { apiCall } = useApiWithRetry('/test/endpoint');

    await expect(apiCall()).rejects.toThrow(NetworkError);
  });

  test('retries failed requests', async () => {
    global.fetch = jest.fn()
      .mockRejectedValueOnce(new TypeError('Network error'))
      .mockRejectedValueOnce(new TypeError('Network error'))
      .mockResolvedValue({
        ok: true,
        json: async () => ({ success: true })
      });

    const { apiCall } = useApiWithRetry('/test/endpoint');

    const result = await apiCall();
    expect(result).toEqual({ success: true });
    expect(fetch).toHaveBeenCalledTimes(3);
  });
});
```

---

## ğŸ“ˆ ç›‘æ§å’Œåˆ†æ

### é”™è¯¯ç»Ÿè®¡åˆ†æ
```typescript
export function useErrorAnalytics() {
  const [analytics, setAnalytics] = useState({
    errorTrends: [],
    topErrors: [],
    errorDistribution: {},
    recoveryRate: 0
  });

  const analyzeErrors = useCallback((errors) => {
    // é”™è¯¯è¶‹åŠ¿åˆ†æ
    const trends = errors.reduce((acc, error) => {
      const hour = new Date(error.timestamp).getHours();
      acc[hour] = (acc[hour] || 0) + 1;
      return acc;
    }, {});

    // é”™è¯¯ç±»å‹åˆ†å¸ƒ
    const distribution = errors.reduce((acc, error) => {
      acc[error.type] = (acc[error.type] || 0) + 1;
      return acc;
    }, {});

    // æ¢å¤ç‡è®¡ç®—
    const retriedErrors = errors.filter(e => e.retryAttempts > 0);
    const recoveredErrors = retriedErrors.filter(e => e.recovered);
    const recoveryRate = retriedErrors.length > 0 
      ? (recoveredErrors.length / retriedErrors.length) * 100 
      : 0;

    setAnalytics({
      errorTrends: Object.entries(trends),
      topErrors: Object.entries(distribution)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 5),
      errorDistribution: distribution,
      recoveryRate
    });
  }, []);

  return { analytics, analyzeErrors };
}
```

---

## ğŸ’¡ æœ€ä½³å®è·µæ€»ç»“

### é”™è¯¯å¤„ç†åŸåˆ™
- **åˆ†å±‚å¤„ç†**ï¼šç½‘ç»œå±‚ã€ä¸šåŠ¡å±‚ã€UIå±‚åˆ†åˆ«å¤„ç†å¯¹åº”é”™è¯¯
- **ç”¨æˆ·å‹å¥½**ï¼šé”™è¯¯ä¿¡æ¯è¦æ¸…æ™°æ˜“æ‡‚ï¼Œæä¾›è§£å†³å»ºè®®
- **è‡ªåŠ¨æ¢å¤**ï¼šå¯æ¢å¤çš„é”™è¯¯è‡ªåŠ¨é‡è¯•ï¼Œå‡å°‘ç”¨æˆ·å¹²é¢„
- **ç›‘æ§æŠ¥è­¦**ï¼šé‡è¦é”™è¯¯åŠæ—¶è®°å½•å’ŒæŠ¥è­¦

### æ€§èƒ½è€ƒè™‘
- **é”™è¯¯è¾¹ç•Œç²’åº¦**ï¼šåˆç†è®¾ç½®é”™è¯¯è¾¹ç•ŒèŒƒå›´
- **é‡è¯•ç­–ç•¥**ï¼šæŒ‡æ•°é€€é¿é¿å…ç³»ç»Ÿè¿‡è½½
- **æ–­è·¯å™¨ä¿æŠ¤**ï¼šé˜²æ­¢çº§è”æ•…éšœ
- **å†…å­˜ç®¡ç†**ï¼šé”™è¯¯æ—¥å¿—å®šæœŸæ¸…ç†

### å®‰å…¨æ€§è®¾è®¡
- **æ•æ„Ÿä¿¡æ¯ä¿æŠ¤**ï¼šé”™è¯¯ä¿¡æ¯ä¸æš´éœ²ç³»ç»Ÿå†…éƒ¨ç»†èŠ‚
- **æ—¥å¿—è„±æ•**ï¼šè®°å½•é”™è¯¯æ—¶è¿‡æ»¤æ•æ„Ÿæ•°æ®
- **è®¿é—®æ§åˆ¶**ï¼šé”™è¯¯ç›‘æ§æ¥å£éœ€è¦æƒé™éªŒè¯

---

## ğŸ“‹ å­¦ä¹ æ£€æŸ¥ç‚¹

### é”™è¯¯å¤„ç†ä½“ç³»å®Œæˆåº¦
- âœ… **é”™è¯¯åˆ†ç±»ç³»ç»Ÿ**ï¼šå®Œæ•´çš„é”™è¯¯ç±»å‹å’Œä¸¥é‡çº§åˆ«å®šä¹‰
- âœ… **é‡è¯•æœºåˆ¶**ï¼šæ™ºèƒ½é‡è¯•å’Œæ–­è·¯å™¨æ¨¡å¼å®ç°
- âœ… **ç”¨æˆ·åé¦ˆ**ï¼šå‹å¥½çš„é”™è¯¯é€šçŸ¥å’Œæ¢å¤å»ºè®®
- âœ… **é”™è¯¯è¾¹ç•Œ**ï¼šReactç»„ä»¶é”™è¯¯æ•è·å’Œæ¢å¤
- âœ… **ç›‘æ§åˆ†æ**ï¼šé”™è¯¯ç»Ÿè®¡ã€è¶‹åŠ¿åˆ†æå’ŒæŠ¥è­¦

### ç³»ç»Ÿå¥å£®æ€§æå‡
- **å®¹é”™èƒ½åŠ›**ï¼šå„ç±»å¼‚å¸¸åœºæ™¯çš„ä¼˜é›…å¤„ç†
- **ç”¨æˆ·ä½“éªŒ**ï¼šé”™è¯¯çŠ¶æ€ä¸‹çš„è‰¯å¥½äº¤äº’ä½“éªŒ
- **ç³»ç»Ÿç¨³å®šæ€§**ï¼šè‡ªåŠ¨æ¢å¤å’Œé™çº§ä¿æŠ¤æœºåˆ¶
- **å¯è§‚æµ‹æ€§**ï¼šå®Œå–„çš„é”™è¯¯ç›‘æ§å’Œåˆ†æèƒ½åŠ›

**æ­å–œå®Œæˆ8.4èŠ‚å­¦ä¹ ï¼æ‚¨å·²å…·å¤‡æ„å»ºä¼ä¸šçº§å¥å£®ç³»ç»Ÿçš„é”™è¯¯å¤„ç†èƒ½åŠ›ï¼** ğŸ‰
